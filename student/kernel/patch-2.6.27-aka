diff -urN linux-2.6.27new/arch/arm/configs/akae2440_defconfig linux-2.6.27/arch/arm/configs/akae2440_defconfig
--- linux-2.6.27new/arch/arm/configs/akae2440_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/arch/arm/configs/akae2440_defconfig	2009-07-23 17:08:11.000000000 +0800
@@ -0,0 +1,978 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.27
+# Mon Jun 15 06:55:49 2009
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_GENERIC_TIME is not set
+# CONFIG_GENERIC_CLOCKEVENTS is not set
+CONFIG_MMU=y
+CONFIG_NO_IOPORT=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_AOUT=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+# CONFIG_EXPERIMENTAL is not set
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_COMPAT_BRK=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_ANON_INODES=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS is not set
+# CONFIG_HAVE_IOREMAP_PROT is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+# CONFIG_HAVE_ARCH_TRACEHOOK is not set
+# CONFIG_HAVE_DMA_ATTRS is not set
+# CONFIG_USE_GENERIC_SMP_HELPERS is not set
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_DEFAULT_AS=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="anticipatory"
+CONFIG_CLASSIC_RCU=y
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+CONFIG_ARCH_S3C2410=y
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM7X00A is not set
+CONFIG_PLAT_S3C24XX=y
+CONFIG_CPU_S3C244X=y
+CONFIG_S3C24XX_PWM=y
+CONFIG_S3C2410_DMA=y
+# CONFIG_S3C2410_DMA_DEBUG is not set
+CONFIG_PLAT_S3C=y
+CONFIG_CPU_LLSERIAL_S3C2410=y
+CONFIG_CPU_LLSERIAL_S3C2440=y
+
+#
+# Boot options
+#
+# CONFIG_S3C_BOOT_ERROR_RESET is not set
+
+#
+# Power management
+#
+CONFIG_S3C_LOWLEVEL_UART_PORT=0
+
+#
+# S3C2400 Machines
+#
+CONFIG_CPU_S3C2410=y
+CONFIG_CPU_S3C2410_DMA=y
+CONFIG_S3C2410_GPIO=y
+CONFIG_S3C2410_CLOCK=y
+
+#
+# S3C2410 Machines
+#
+# CONFIG_ARCH_SMDK2410 is not set
+# CONFIG_ARCH_H1940 is not set
+# CONFIG_MACH_N30 is not set
+# CONFIG_ARCH_BAST is not set
+# CONFIG_MACH_OTOM is not set
+# CONFIG_MACH_AML_M5900 is not set
+# CONFIG_MACH_TCT_HAMMER is not set
+# CONFIG_MACH_VR1000 is not set
+# CONFIG_MACH_QT2410 is not set
+CONFIG_MACH_AKAE2410=y
+
+#
+# S3C2412 Machines
+#
+# CONFIG_MACH_JIVE is not set
+# CONFIG_MACH_SMDK2413 is not set
+# CONFIG_MACH_SMDK2412 is not set
+# CONFIG_MACH_VSTMS is not set
+CONFIG_CPU_S3C2440=y
+CONFIG_S3C2440_DMA=y
+
+#
+# S3C2440 Machines
+#
+# CONFIG_MACH_ANUBIS is not set
+# CONFIG_MACH_OSIRIS is not set
+# CONFIG_MACH_RX3715 is not set
+# CONFIG_ARCH_S3C2440 is not set
+# CONFIG_MACH_NEXCODER_2440 is not set
+CONFIG_MACH_AKAE2440=y
+# CONFIG_MACH_AT2440EVB is not set
+
+#
+# S3C2442 Machines
+#
+
+#
+# S3C2443 Machines
+#
+# CONFIG_MACH_SMDK2443 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM920T=y
+CONFIG_CPU_32v4T=y
+CONFIG_CPU_ABRT_EV4T=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_V4WT=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_TICK_ONESHOT is not set
+CONFIG_HZ=200
+# CONFIG_AEABI is not set
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+# CONFIG_SPARSEMEM_VMEMMAP_ENABLE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="root=/dev/hda1 ro init=/bin/bash console=ttySAC0"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_IPV6 is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+
+#
+# Wireless
+#
+# CONFIG_CFG80211 is not set
+# CONFIG_WIRELESS_EXT is not set
+# CONFIG_MAC80211 is not set
+# CONFIG_IEEE80211 is not set
+# CONFIG_RFKILL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+CONFIG_MTD_ROM=y
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+CONFIG_MTD_NAND_S3C2410=y
+CONFIG_MTD_NAND_S3C2410_DEBUG=y
+# CONFIG_MTD_NAND_S3C2410_HWECC is not set
+# CONFIG_MTD_NAND_S3C2410_CLKSTOP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=32768
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_ANDROID_PMEM=y
+CONFIG_TIMED_OUTPUT=y
+CONFIG_TIMED_GPIO=y
+CONFIG_BINDER_IPC=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+CONFIG_LOW_MEMORY_KILLER=y
+CONFIG_LOGGER=y
+# CONFIG_UID_STAT is not set
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_CS8900=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+CONFIG_NET_PCI=y
+# CONFIG_B44 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_SAMSUNG=y
+# CONFIG_SERIAL_SAMSUNG_DEBUG is not set
+CONFIG_SERIAL_SAMSUNG_CONSOLE=y
+CONFIG_SERIAL_S3C2410=y
+CONFIG_SERIAL_S3C2440=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_DCC_TTY is not set
+# CONFIG_I2C is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+
+#
+# I2C GPIO expanders:
+#
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_SWITCH is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# Voltage and Current regulators
+#
+# CONFIG_REGULATOR is not set
+# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_BQ24022 is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+# CONFIG_PROC_FS is not set
+# CONFIG_SYSFS is not set
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_YAFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+CONFIG_LOCKD=y
+CONFIG_EXPORTFS=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_HAVE_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+# CONFIG_FTRACE is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_CONTEXT_SWITCH_TRACER is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_S3C_UART=0
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_MANAGER=m
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=m
+# CONFIG_CRYPTO_PCBC is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=m
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=m
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=m
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_GENERIC_FIND_FIRST_BIT is not set
+# CONFIG_GENERIC_FIND_NEXT_BIT is not set
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
diff -urN linux-2.6.27new/arch/arm/mach-s3c2410/Kconfig linux-2.6.27/arch/arm/mach-s3c2410/Kconfig
--- linux-2.6.27new/arch/arm/mach-s3c2410/Kconfig	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2410/Kconfig	2009-07-23 17:08:11.000000000 +0800
@@ -132,5 +132,10 @@
 	select CPU_S3C2410
 	help
 	   Say Y here if you are using the Armzone QT2410
+config MACH_AKAE2410
+	bool "AKAE2410"
+	select CPU_S3C2410
+	help
+	   Say Y here if you are using the AKAE2410 board
 
 endmenu
diff -urN linux-2.6.27new/arch/arm/mach-s3c2410/mach-akae2410.c linux-2.6.27/arch/arm/mach-s3c2410/mach-akae2410.c
--- linux-2.6.27new/arch/arm/mach-s3c2410/mach-akae2410.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2410/mach-akae2410.c	2009-07-23 17:08:11.000000000 +0800
@@ -0,0 +1,137 @@
+/* linux/arch/arm/mach-s3c2410/mach-akaedu2410.c
+ *
+ * linux/arch/arm/mach-s3c2410/mach-akaedu2410.c
+ *
+ * Copyright (C) 2004 by FS Forth-Systeme GmbH
+ * All rights reserved.
+ *
+ * $Id: mach-akaedu2410.c,v 1.1 2004/05/11 14:15:38 mpietrek Exp $
+ * @Author: Jonas Dietsche
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * @History:
+ * derived from linux/arch/arm/mach-s3c2410/mach-bast.c, written by
+ * Ben Dooks <ben@simtec.co.uk>
+ *
+ ***********************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/sysdev.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/leds-gpio.h>
+#include <asm/plat-s3c/regs-serial.h>
+#include <mach/fb.h>
+#include <asm/plat-s3c/nand.h>
+#include <asm/plat-s3c24xx/udc.h>
+#include <mach/spi.h>
+#include <mach/spi-gpio.h>
+
+#include <asm/plat-s3c24xx/common-smdk.h>
+#include <asm/plat-s3c24xx/devs.h>
+#include <asm/plat-s3c24xx/cpu.h>
+#include <asm/plat-s3c24xx/pm.h>
+
+static struct map_desc akaedu2410_iodesc[] __initdata = {
+	{ 0xe0000000, __phys_to_pfn(S3C2410_CS3+0x01000000), SZ_1M, MT_DEVICE }
+};
+
+
+#define UCON S3C2410_UCON_DEFAULT
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+
+static struct s3c2410_uartcfg akaedu2410_uartcfgs[] __initdata = {
+	[0] = {
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[1] = {
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[2] = {
+		.hwport	     = 2,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	}
+};
+
+static struct platform_device *akaedu2410_devices[] __initdata = {
+	&s3c_device_usb,
+	&s3c_device_lcd,
+	&s3c_device_wdt,
+	&s3c_device_i2c,
+	&s3c_device_iis,
+};
+
+static void __init akaedu2410_map_io(void)
+{
+	s3c24xx_init_io(akaedu2410_iodesc, ARRAY_SIZE(akaedu2410_iodesc));
+	s3c24xx_init_clocks(0);
+	s3c24xx_init_uarts(akaedu2410_uartcfgs, ARRAY_SIZE(akaedu2410_uartcfgs));
+}
+
+static void __init akaedu2410_init(void)
+{
+	platform_add_devices(akaedu2410_devices, ARRAY_SIZE(akaedu2410_devices));
+}
+
+MACHINE_START(AKAE2410, "AKAE2410") /* @TODO: request a new identifier and switch
+				    * to akaedu2410 */
+	/* Maintainer: Jonas Dietsche */
+	.phys_io	= S3C2410_PA_UART,
+	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C2410_SDRAM_PA + 0x100,
+	.map_io		= akaedu2410_map_io,
+	.init_irq	= s3c24xx_init_irq,
+	.init_machine	= akaedu2410_init,
+	.timer		= &s3c24xx_timer,
+MACHINE_END
+
+
diff -urN linux-2.6.27new/arch/arm/mach-s3c2410/Makefile linux-2.6.27/arch/arm/mach-s3c2410/Makefile
--- linux-2.6.27new/arch/arm/mach-s3c2410/Makefile	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2410/Makefile	2009-07-23 17:08:11.000000000 +0800
@@ -30,6 +30,7 @@
 obj-$(CONFIG_MACH_TCT_HAMMER)	+= mach-tct_hammer.o
 obj-$(CONFIG_MACH_VR1000)	+= mach-vr1000.o usb-simtec.o
 obj-$(CONFIG_MACH_QT2410)	+= mach-qt2410.o
+obj-$(CONFIG_MACH_AKAE2410)	+= mach-akae2410.o
 
 # Common bits of machine support
 
diff -urN linux-2.6.27new/arch/arm/mach-s3c2440/Kconfig linux-2.6.27/arch/arm/mach-s3c2440/Kconfig
--- linux-2.6.27new/arch/arm/mach-s3c2440/Kconfig	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2440/Kconfig	2009-07-23 17:08:11.000000000 +0800
@@ -68,6 +68,12 @@
 	default y if ARCH_S3C2440
 	select CPU_S3C2440
 
+config MACH_AKAE2440
+	bool "AKAE2440 with S3C2440 CPU module"
+	select CPU_S3C2440
+	help
+	  Say Y here if you are using the AKAE2440 development board
+
 config MACH_AT2440EVB
 	bool "Avantech AT2440EVB development board"
 	select CPU_S3C2440
diff -urN linux-2.6.27new/arch/arm/mach-s3c2440/mach-akae2440.c linux-2.6.27/arch/arm/mach-s3c2440/mach-akae2440.c
--- linux-2.6.27new/arch/arm/mach-s3c2440/mach-akae2440.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2440/mach-akae2440.c	2009-07-23 17:08:11.000000000 +0800
@@ -0,0 +1,235 @@
+/* linux/arch/arm/mach-s3c2440/mach-akae2440.c
+ *
+ * Copyright (c) 2004,2005 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ * Copyright (c) 2009 akaedu
+ *	weiqin <qinwei1998@hotmail.com> 
+ *
+ * Thanks to Dimity Andric and TomTom for the loan of an SMDK2440.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/plat-s3c/regs-serial.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-lcd.h>
+
+#include <mach/idle.h>
+#include <mach/fb.h>
+
+#include <asm/plat-s3c24xx/s3c2410.h>
+#include <asm/plat-s3c24xx/s3c2440.h>
+#include <asm/plat-s3c24xx/clock.h>
+#include <asm/plat-s3c24xx/devs.h>
+#include <asm/plat-s3c24xx/cpu.h>
+
+#include <asm/plat-s3c24xx/common-smdk.h>
+#include <mach/regs-mem.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/leds-gpio.h>
+#include <asm/plat-s3c/regs-serial.h>
+#include <mach/fb.h>
+#include <asm/plat-s3c/nand.h>
+#include <asm/plat-s3c24xx/udc.h>
+#include <mach/spi.h>
+#include <mach/spi-gpio.h>
+
+static struct map_desc akae2440_iodesc[] __initdata = {
+	/* cs8900 IO Space map */
+	{   .virtual    = 0xe0000000,
+		.pfn        = __phys_to_pfn(S3C2410_CS3+0x01000000), 
+		.length     = SZ_1M,
+		.type       = MT_DEVICE 
+	}
+};
+
+#define UCON S3C2410_UCON_DEFAULT | S3C2410_UCON_UCLK
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+
+static struct s3c2410_uartcfg akae2440_uartcfgs[] __initdata = {
+	[0] = {
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = 0x3c5,
+		.ulcon	     = 0x03,
+		.ufcon	     = 0x51,
+	},
+	[1] = {
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = 0x3c5,
+		.ulcon	     = 0x03,
+		.ufcon	     = 0x51,
+	},
+	/* IR port */
+	[2] = {
+		.hwport	     = 2,
+		.flags	     = 0,
+		.ucon	     = 0x3c5,
+		.ulcon	     = 0x43,
+		.ufcon	     = 0x51,
+	}
+};
+
+/* LCD driver info */
+static struct s3c2410fb_display akae2440_lcd_cfg __initdata = {
+
+	.lcdcon5	= S3C2410_LCDCON5_FRM565 |
+			  S3C2410_LCDCON5_INVVLINE |
+			  S3C2410_LCDCON5_INVVFRAME |
+			  S3C2410_LCDCON5_PWREN |
+			  S3C2410_LCDCON5_HWSWP,
+
+	.type		= S3C2410_LCDCON1_TFT,
+
+	.width		= 240,
+	.height		= 320,
+
+	.pixclock	= 166667, /* HCLK 60 MHz, divisor 10 */
+	.xres		= 240,
+	.yres		= 320,
+	.bpp		= 16,
+	.left_margin	= 20,
+	.right_margin	= 8,
+	.hsync_len	= 4,
+	.upper_margin	= 8,
+	.lower_margin	= 7,
+	.vsync_len	= 4,
+};
+
+static struct s3c2410fb_mach_info akae2440_fb_info __initdata = {
+	.displays	= &akae2440_lcd_cfg,
+	.num_displays	= 1,
+	.default_display = 0,
+	.lpcsel	= ((0xCE6) & ~7) | 1<<4,
+};
+
+/* CS8900 */
+static struct resource akae24xx_cs89x0_resources[] = {
+	[0] = {
+		.start	= 0x19000000,
+		.end	= 0x19000000 + 16,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_EINT9,
+		.end	= IRQ_EINT9,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device akae24xx_cs89x0 = {
+	.name		= "cs89x0",
+	.num_resources	= ARRAY_SIZE(akae24xx_cs89x0_resources),
+	.resource	= akae24xx_cs89x0_resources,
+};
+
+
+static struct platform_device *akae2440_devices[] __initdata = {
+	&s3c_device_usb,
+	&s3c_device_lcd,
+	&s3c_device_wdt,
+	&s3c_device_i2c,
+	&s3c_device_iis,
+	&s3c_device_nand,
+	&s3c_device_rtc,
+	&akae24xx_cs89x0,
+};
+
+
+static struct s3c2410_nand_set akae2440_nand_sets[] = {
+	[0] = {
+		.name		= "akae2440-nand",
+		.nr_chips	= 1,
+		.nr_partitions	= 0,
+		.partitions	= NULL,
+	},
+};
+
+static struct s3c2410_platform_nand akae2440_nand_info = {
+	.tacls		= 25,
+	.twrph0		= 55,
+	.twrph1		= 40,
+	.nr_sets	= ARRAY_SIZE(akae2440_nand_sets),
+	.sets		= akae2440_nand_sets,
+};
+
+
+static void __init akae2440_map_io(void)
+{
+	s3c24xx_init_io(akae2440_iodesc, ARRAY_SIZE(akae2440_iodesc));
+	s3c24xx_init_clocks(12000000);
+	s3c24xx_init_uarts(akae2440_uartcfgs, ARRAY_SIZE(akae2440_uartcfgs));
+}
+
+static void __init akae2440_machine_init(void)
+{
+	unsigned long bus_conf;
+	unsigned long flags;
+	unsigned long temp;
+
+	/* Configure the LEDs (even if we have no LED support)*/
+	s3c2410_gpio_cfgpin(S3C2410_GPF4, S3C2410_GPF4_OUTP);
+	s3c2410_gpio_cfgpin(S3C2410_GPF5, S3C2410_GPF5_OUTP);
+	s3c2410_gpio_cfgpin(S3C2410_GPF6, S3C2410_GPF6_OUTP);
+	s3c2410_gpio_cfgpin(S3C2410_GPF7, S3C2410_GPF7_OUTP);
+
+	s3c2410_gpio_setpin(S3C2410_GPF4, 1);
+	s3c2410_gpio_setpin(S3C2410_GPF5, 1);
+	s3c2410_gpio_setpin(S3C2410_GPF6, 1);
+	s3c2410_gpio_setpin(S3C2410_GPF7, 1);
+
+	s3c24xx_fb_set_platdata(&akae2440_fb_info);
+	s3c_device_nand.dev.platform_data = &akae2440_nand_info;
+	
+	platform_add_devices(akae2440_devices, ARRAY_SIZE(akae2440_devices));
+	
+	local_irq_save(flags);
+	bus_conf = __raw_readl(S3C2410_BWSCON);
+	__raw_writel(  (bus_conf & ~0x0000F000) | 0x0000D000, S3C2410_BWSCON );
+	__raw_writel(0x1f7c,S3C2410_BANKCON3);
+
+	s3c2410_gpio_cfgpin(S3C2410_GPG1, S3C2410_GPG1_EINT9);
+	temp = __raw_readl(S3C2410_EXTINT1);
+	__raw_writel(  (temp & ~0x00000070) | 0x00000060, S3C2410_EXTINT1 );
+
+	local_irq_restore(flags);
+}
+
+MACHINE_START(AKAE2440, "AKAE2440")
+	.phys_io	= S3C2410_PA_UART,
+	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C2410_SDRAM_PA + 0x100,
+	.init_irq	= s3c24xx_init_irq,
+	.map_io		= akae2440_map_io,
+	.init_machine	= akae2440_machine_init,
+	.timer		= &s3c24xx_timer,
+MACHINE_END
diff -urN linux-2.6.27new/arch/arm/mach-s3c2440/Makefile linux-2.6.27/arch/arm/mach-s3c2440/Makefile
--- linux-2.6.27new/arch/arm/mach-s3c2440/Makefile	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/mach-s3c2440/Makefile	2009-07-23 17:08:11.000000000 +0800
@@ -20,5 +20,6 @@
 obj-$(CONFIG_MACH_OSIRIS)	+= mach-osiris.o
 obj-$(CONFIG_MACH_RX3715)	+= mach-rx3715.o
 obj-$(CONFIG_ARCH_S3C2440)	+= mach-smdk2440.o
+obj-$(CONFIG_MACH_AKAE2440)	+= mach-akae2440.o
 obj-$(CONFIG_MACH_NEXCODER_2440) += mach-nexcoder.o
 obj-$(CONFIG_MACH_AT2440EVB) += mach-at2440evb.o
diff -urN linux-2.6.27new/arch/arm/plat-s3c24xx/time.c linux-2.6.27/arch/arm/plat-s3c24xx/time.c
--- linux-2.6.27new/arch/arm/plat-s3c24xx/time.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/plat-s3c24xx/time.c	2009-07-23 17:08:11.000000000 +0800
@@ -209,7 +209,7 @@
 		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
 		tcfg0 |= ((6 - 1) / 2) << S3C2410_TCFG_PRESCALER1_SHIFT;
 
-		tcnt = (pclk / 6) / HZ;
+		tcnt = ((pclk / 6) / HZ)/10;
 	}
 
 	/* timers reload after counting zero, so reduce the count by 1 */
diff -urN linux-2.6.27new/arch/arm/tools/mach-types linux-2.6.27/arch/arm/tools/mach-types
--- linux-2.6.27new/arch/arm/tools/mach-types	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/arch/arm/tools/mach-types	2009-07-23 17:08:11.000000000 +0800
@@ -1861,3 +1861,5 @@
 imx27ipcam		MACH_IMX27IPCAM		IMX27IPCAM		1871
 nenoc			MACH_NEMOC		NEMOC			1872
 geneva			MACH_GENEVA		GENEVA			1873
+akae2410		MACH_AKAE2410		AKAE2410		1874
+akae2440		MACH_AKAE2440		AKAE2440		1875
\ 文件结尾缺少空行
diff -urN linux-2.6.27new/Documentation/DocBook/index.html linux-2.6.27/Documentation/DocBook/index.html
--- linux-2.6.27new/Documentation/DocBook/index.html	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/Documentation/DocBook/index.html	2009-07-23 17:08:11.000000000 +0800
@@ -0,0 +1,29 @@
+<h1>Linux Kernel HTML Documentation</h1>
+<h2>Kernel Version: 2.6.27</h2>
+<a HREF="debugobjects/index.html"> debugobjects</a><p>
+<a HREF="deviceiobook/index.html"> deviceiobook</a><p>
+<a HREF="filesystems/index.html"> filesystems</a><p>
+<a HREF="gadget/index.html"> gadget</a><p>
+<a HREF="genericirq/index.html"> genericirq</a><p>
+<a HREF="kernel-api/index.html"> kernel-api</a><p>
+<a HREF="kernel-hacking/index.html"> kernel-hacking</a><p>
+<a HREF="kernel-locking/index.html"> kernel-locking</a><p>
+<a HREF="kgdb/index.html"> kgdb</a><p>
+<a HREF="libata/index.html"> libata</a><p>
+<a HREF="librs/index.html"> librs</a><p>
+<a HREF="lsm/index.html"> lsm</a><p>
+<a HREF="mac80211/index.html"> mac80211</a><p>
+<a HREF="mcabook/index.html"> mcabook</a><p>
+<a HREF="mtdnand/index.html"> mtdnand</a><p>
+<a HREF="networking/index.html"> networking</a><p>
+<a HREF="procfs-guide/index.html"> procfs-guide</a><p>
+<a HREF="rapidio/index.html"> rapidio</a><p>
+<a HREF="s390-drivers/index.html"> s390-drivers</a><p>
+<a HREF="scsi/index.html"> scsi</a><p>
+<a HREF="sh/index.html"> sh</a><p>
+<a HREF="uio-howto/index.html"> uio-howto</a><p>
+<a HREF="usb/index.html"> usb</a><p>
+<a HREF="videobook/index.html"> videobook</a><p>
+<a HREF="wanbook/index.html"> wanbook</a><p>
+<a HREF="writing_usb_driver/index.html"> writing_usb_driver</a><p>
+<a HREF="z8530book/index.html"> z8530book</a><p>
diff -urN linux-2.6.27new/drivers/mtd/nand/s3c2410.c linux-2.6.27/drivers/mtd/nand/s3c2410.c
--- linux-2.6.27new/drivers/mtd/nand/s3c2410.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/mtd/nand/s3c2410.c	2009-07-23 17:08:11.000000000 +0800
@@ -645,16 +645,32 @@
 }
 
 #ifdef CONFIG_MTD_PARTITIONS
+
+const char *part_probes[] = { "cmdlinepart", NULL };
+
 static int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,
 				      struct s3c2410_nand_mtd *mtd,
 				      struct s3c2410_nand_set *set)
 {
+	struct mtd_partition *part_info;
+	int nr_part = 0;
+
 	if (set == NULL)
 		return add_mtd_device(&mtd->mtd);
 
-	if (set->nr_partitions > 0 && set->partitions != NULL) {
-		return add_mtd_partitions(&mtd->mtd, set->partitions, set->nr_partitions);
-	}
+	if (set->nr_partitions == 0) {
+		mtd->mtd.name = set->name;
+		nr_part = parse_mtd_partitions(&mtd->mtd, part_probes,
+						&part_info, 0);
+	} else {
+		if (set->nr_partitions > 0 && set->partitions != NULL) {
+			nr_part = set->nr_partitions;
+			part_info = set->partitions;
+		}
+ 	}
+ 
+	if (nr_part > 0 && part_info)
+		return add_mtd_partitions(&mtd->mtd, part_info, nr_part);
 
 	return add_mtd_device(&mtd->mtd);
 }
diff -urN linux-2.6.27new/drivers/net/arm/cs8900.c linux-2.6.27/drivers/net/arm/cs8900.c
--- linux-2.6.27new/drivers/net/arm/cs8900.c	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/drivers/net/arm/cs8900.c	2009-07-23 17:20:33.000000000 +0800
@@ -0,0 +1,964 @@
+#define VERSION_STRING "Cirrus Logic CS8900A driver for Linux (Modified for SMDK2410//SMDK2440)"
+
+
+/*
+ * TODO:
+ *
+ *   1. Sort out ethernet checksum
+ *   2. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   3. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   4. Change reset code to check status.
+ *   5. Implement set_mac_address and remove fake mac address
+ *   7. Link status detection stuff
+ *   8. Write utility to write EEPROM, do self testing, etc.
+ *   9. Implement DMA routines (I need a board w/ DMA support for that)
+ *  10. Power management
+ *  11. Add support for multiple ethernet chips
+ */
+
+// added BSt
+//#include <linux/config.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <linux/irq.h>
+#include <linux/fs.h>
+#include <asm/irq.h>
+//#include <asm/hardware.h>
+#include <mach/hardware.h> /* ++ */
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+// Added BSt
+#include <asm/mach-types.h>
+
+/* #include <asm/arch/regs-mem.h> */
+
+#ifdef CONFIG_ARCH_SMDK2410
+#include "asm/arch/smdk2410.h" /* ++ */
+#endif
+
+#include "cs8900.h"
+
+//#define FULL_DUPLEX
+//#define DEBUG
+//#define CONFIG_ARCH_SMDK2410
+
+static char version_string[] __initdata = "Cirrus Logic CS8900A driver for Linux (Modified for SMDK2410/SMDK2440 By Bryan Wang)";
+
+typedef struct {
+	struct net_device_stats stats;
+	u16 txlen;
+	int char_devnum;
+
+        spinlock_t lock;
+#ifdef CONFIG_PM
+    struct pm_dev *pmdev;
+#endif
+} cs8900_t;
+
+/* 自己声明一个包含struct net_device结构体指针的私有结构体 struct mycs8900_private. */
+struct mycs8900_private {
+	struct net_device *dev;
+};
+
+struct mycs8900_private *mcp;
+
+//int cs8900_probe(struct net_device *dev);
+
+static struct net_device *dev_cs8900; //保存用来unregister_netdev用的.
+
+/* 改为动态分配 */
+/*static struct net_device cs8900_dev =
+{
+        init: cs8900_probe
+};*/
+
+/* 
+ * There seems to be no way to determine the exact size of the eeprom, 
+ * so we use the largest size.
+ * FIXME: Verify it's safe to read/write past the end of a 64/128
+ *        byte eeprom. 
+ *
+ * Possible eeprom sizes: 
+ * Cx46 -  64 bytes
+ * Cx56 - 128 bytes
+ * Cx66 - 256 bytes
+ */
+#define MAX_EEPROM_SIZE		256
+
+
+static int cs8900_eeprom_fopen(struct inode *inode, struct file *file);
+static int cs8900_eeprom_frelease(struct inode *inode, struct file *file);
+static loff_t cs8900_eeprom_fllseek(struct file * file,loff_t offset, int flags);
+static ssize_t cs8900_eeprom_fread(struct file *file, char *buf, size_t count, loff_t *f_pos);
+static ssize_t cs8900_eeprom_fwrite(struct file *file, const char *buf, size_t count, loff_t *f_pos);
+static struct file_operations cs8900_eeprom_fops = {
+        .owner    =     THIS_MODULE,
+        .open     =     cs8900_eeprom_fopen,
+        .release  =     cs8900_eeprom_frelease,
+        .llseek   =     cs8900_eeprom_fllseek,
+        .read     =     cs8900_eeprom_fread,
+        .write    =     cs8900_eeprom_fwrite,
+};      
+
+static u16 cs8900_eeprom_cache[MAX_EEPROM_SIZE/2];
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cs8900_read (struct net_device *dev,u16 reg)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	return (inw (dev->base_addr + PP_Data));
+}
+
+static inline void cs8900_write (struct net_device *dev,u16 reg,u16 value)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	outw (value,dev->base_addr + PP_Data);
+}
+
+static inline void cs8900_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cs8900_write (dev,reg,cs8900_read (dev,reg) | value);
+}
+
+static inline void cs8900_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cs8900_write (dev,reg,cs8900_read (dev,reg) & ~value);
+}
+
+static inline void cs8900_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	insw (dev->base_addr,skb_put (skb,length),(length + 1) / 2);
+}
+
+static inline void cs8900_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	outsw (dev->base_addr,skb->data,(skb->len + 1) / 2);
+}
+
+
+/*
+ * EEPROM I/O routines
+ */
+
+static int cs8900_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 3000; i++) {
+		if (!(cs8900_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cs8900_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cs8900_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cs8900_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cs8900_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cs8900_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cs8900_eeprom_write (struct net_device *dev,u16 *value,u16 offset)
+{
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (EEWriteEnable));
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMData, *value);
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (offset | EEWriteRegister));
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (EEWriteDisable));
+	cs8900_eeprom_wait(dev);
+
+        return 0;
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+
+static void eepromdump( struct net_device *dev)
+{
+	u16 buf[0x80];
+	u16 i;
+	int count;
+	int total;
+
+	if( cs8900_read( dev, PP_SelfST) & EEPROMpresent)
+	{
+		printk (KERN_INFO "%s: EEPROM present\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: NO EEPROM present\n",dev->name);
+		return;
+	}
+
+	if( cs8900_read( dev, PP_SelfST) & EEPROMOK)
+	{
+		printk (KERN_INFO "%s: EEPROM OK\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: EEPROM checksum mismatch - fixing...\n",dev->name);
+	}
+
+	printk (KERN_INFO "%s: Hexdump\n",dev->name);
+	for( i=0; i<0x80; i++)
+	{
+		cs8900_eeprom_read( dev, &buf[i], i);
+	}
+	hexdump( dev, buf, 0x100);
+
+	if( buf[0] & 0x0100)
+	{
+		printk (KERN_INFO "%s: non-sequential EEPROM\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: sequential EEPROM\n",dev->name);
+	}
+
+	if( (buf[0] & 0xe000) == 0xa000)
+	{
+		printk (KERN_INFO "%s: Found reset configuration block\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: Reset configuration block not found\n",dev->name);
+		return;
+	}
+
+	count = 2;
+	total = buf[0] & 0xff;
+	printk (KERN_INFO "%s: Reset configuration block size = %d bytes\n",dev->name, total);
+
+	while( count < total)
+	{
+		int groupsize = (buf[count/2] >> 12) + 1;
+		int basereg = (buf[count/2] &0x1ff);
+		printk (KERN_INFO "%s: Group size = %d words\n",dev->name, groupsize);
+		printk (KERN_INFO "%s:  Base register = %x\n",dev->name, basereg);
+		count += (groupsize + 1)*2;
+	}
+}
+
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cs8900_receive (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cs8900_read (dev,PP_RxStatus);
+	length = cs8900_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 2)) == NULL) { 
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cs8900_frame_read (dev,skb,length);
+
+//#ifdef FULL_DUPLEX
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef FULL_DUPLEX */
+
+	skb->protocol = eth_type_trans (skb,dev); 
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cs8900_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	u16 status;
+
+	spin_lock_irq(&priv->lock);
+	netif_stop_queue (dev); 
+
+	cs8900_write (dev,PP_TxCMD,TxStart (After5)); 
+	cs8900_write (dev,PP_TxLength,skb->len); 
+
+	status = cs8900_read (dev,PP_BusST);
+
+	if ((status & TxBidErr)) {
+		spin_unlock_irq(&priv->lock);
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+		spin_unlock_irq(&priv->lock);
+		printk (KERN_WARNING "%s: Transmit buffer not free!\n",dev->name);
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		/* FIXME: store skb and send it in interrupt handler */
+		return (1);
+	}
+
+	cs8900_frame_write (dev,skb); 
+	spin_unlock_irq(&priv->lock);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+//static irqreturn_t cs8900_interrupt (int irq,void *id,struct pt_regs *regs)
+static irqreturn_t cs8900_interrupt (int irq,void *id) /* ++ */
+{
+	struct net_device *dev = (struct net_device *) id;
+	cs8900_t *priv;
+	volatile u16 status;
+     irqreturn_t handled = 0;
+
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		return 0;
+	}
+
+	priv = (cs8900_t *) dev->priv;
+	
+	while ((status = cs8900_read (dev, PP_ISQ))) {
+		handled = 1;
+		switch (RegNum (status)) {
+		case RxEvent:
+			cs8900_receive (dev);
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cs8900_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cs8900_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				priv->stats.tx_fifo_errors++;
+
+				priv->txlen = 0;
+				netif_wake_queue (dev);
+			}
+			/* FIXME: if Rdy4Tx, transmit last sent packet (if any) */
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cs8900_read (dev,PP_TxCOL));
+			break;
+
+		case RxMISS:
+			status = MissCount (cs8900_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			break;
+		}
+	}
+	return IRQ_RETVAL(handled);
+}
+
+static void cs8900_transmit_timeout (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cs8900_start (struct net_device *dev)
+{
+	int result;
+
+#if defined(CONFIG_MACH_AKAE2440)
+	set_irq_type(dev->irq, IRQF_TRIGGER_RISING);
+
+	/* enable the ethernet controller */
+	cs8900_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cs8900_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cs8900_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cs8900_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cs8900_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cs8900_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cs8900_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+	udelay(200);	
+	/* install interrupt handler */
+	if ((result = request_irq (dev->irq, &cs8900_interrupt, 0, dev->name, dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name, dev->irq);
+		return (result);
+	}
+#else
+	
+	/* install interrupt handler */
+	if ((result = request_irq (dev->irq, &cs8900_interrupt, 0, dev->name, dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name, dev->irq);
+		return (result);
+	}
+
+	set_irq_type(dev->irq, IRQF_TRIGGER_RISING);
+
+	/* enable the ethernet controller */
+	cs8900_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cs8900_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cs8900_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cs8900_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cs8900_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cs8900_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cs8900_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+	
+#endif /* #if defined(CONFIG_MACH_AKAE2440) */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	return (0);
+}
+
+static int cs8900_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cs8900_write (dev,PP_BusCTL,0);
+	cs8900_write (dev,PP_TestCTL,0);
+	cs8900_write (dev,PP_SelfCTL,0);
+	cs8900_write (dev,PP_LineCTL,0);
+	cs8900_write (dev,PP_BufCFG,0);
+	cs8900_write (dev,PP_TxCFG,0);
+	cs8900_write (dev,PP_RxCTL,0);
+	cs8900_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	return (0);
+}
+
+static struct net_device_stats *cs8900_get_stats (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	return (&priv->stats);
+}
+
+static void cs8900_set_receive_mode (struct net_device *dev)
+{
+	if ((dev->flags & IFF_PROMISC))
+		cs8900_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cs8900_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) && dev->mc_list)
+		cs8900_set (dev,PP_RxCTL,MulticastA);
+	else
+		cs8900_clear (dev,PP_RxCTL,MulticastA);
+}
+
+static int cs8900_eeprom (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	int i;
+
+	/* SMDK2410 CS8900A without EEPROM at all */
+#if defined(CONFIG_MACH_AKAE2440)
+	return (-ENODEV);
+#endif 
+
+#ifdef DEBUG
+	eepromdump (dev);
+#endif
+
+	if( (cs8900_read( dev, PP_SelfST) & EEPROMpresent) == 0)
+	{
+		/* no eeprom */
+		return (-ENODEV);
+	}
+
+	/* add character device for easy eeprom programming */
+	if( (priv->char_devnum=register_chrdev(0,"cs8900_eeprom",&cs8900_eeprom_fops)) != 0)
+		printk (KERN_INFO "%s: Registered cs8900_eeprom char device (major #%d)\n",
+			dev->name, priv->char_devnum);
+	else
+		printk (KERN_WARNING "%s: Failed to register char device cs8900_eeprom\n",dev->name);
+
+	if( (cs8900_read( dev, PP_SelfST) & EEPROMOK) == 0) 
+	{
+		/* bad checksum, invalid config block */
+		return (-EFAULT);
+	}
+
+	/* If we get here, the chip will have initialized the registers
+	 * that were specified in the eeprom configuration block
+	 * We assume this is at least the mac address.
+	 */
+	for (i = 0; i < ETH_ALEN; i += 2)
+	{
+		u16 mac = cs8900_read (dev,PP_IA + i);
+		dev->dev_addr[i] = mac & 0xff;
+		dev->dev_addr[i+1] = (mac>>8) & 0xff;
+	}
+
+	return (0);
+}
+
+/*
+ * EEPROM Charater device
+ */
+
+static int cs8900_eeprom_fopen(struct inode *inode, struct file *file)
+{
+	u16 i;
+	for( i=0; i<MAX_EEPROM_SIZE/2; i++)
+	{
+		cs8900_eeprom_read( dev_cs8900, &cs8900_eeprom_cache[i],i);
+	}
+
+	return 0;
+}
+
+static int cs8900_eeprom_frelease(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static loff_t cs8900_eeprom_fllseek(struct file * file,loff_t offset, int whence)
+{
+	long newpos;
+
+	switch(whence)
+	{
+		case 0: /* SEEK_SET */
+			newpos = offset;
+			break;
+		case 1: /* SEEK_CUR */
+			newpos = file->f_pos + offset;
+			break;
+		case 2: /* SEEK_END */
+			newpos = (MAX_EEPROM_SIZE-1) - offset;
+			break;
+		default: /* can't happen */
+			return -EINVAL;
+
+	}
+
+	if( (newpos<0) || (newpos>=MAX_EEPROM_SIZE)) return -EINVAL;
+
+	file->f_pos = newpos;
+	return newpos;
+}
+
+static ssize_t cs8900_eeprom_fread(struct file *file, char *buf, size_t count, loff_t *f_pos)
+{
+	unsigned char *temp = (unsigned char *)cs8900_eeprom_cache;
+
+        if (*f_pos >= MAX_EEPROM_SIZE)
+                return 0;
+
+        if (*f_pos + count > MAX_EEPROM_SIZE)
+            count = MAX_EEPROM_SIZE - *f_pos;
+
+        if (count<1)
+                return 0;
+
+        if (copy_to_user(buf, &temp[*f_pos], count)){
+                return -EFAULT;
+        }
+        *f_pos += count;
+        return count;
+}
+
+static ssize_t cs8900_eeprom_fwrite(struct file *file, const char *buf, size_t count, loff_t *f_pos)
+{
+	u16 i;
+	unsigned char *temp = (unsigned char *)cs8900_eeprom_cache;
+
+        if (*f_pos >= MAX_EEPROM_SIZE)
+                return 0;
+
+        if (*f_pos + count > MAX_EEPROM_SIZE)
+            count = MAX_EEPROM_SIZE - *f_pos;
+
+        if (count<1)
+                return 0;
+
+	/* FIXME: lock critical section */
+
+	/* update the cache */
+        if (copy_from_user(&temp[*f_pos], buf, count)){
+                return -EFAULT;
+        }
+
+	/* not concerned about performance, so write the entire thing */
+	for( i=0; i<MAX_EEPROM_SIZE/2; i++)
+	{
+		cs8900_eeprom_write( dev_cs8900, &cs8900_eeprom_cache[i],i);
+	}
+
+        *f_pos += count;
+        return count;
+}
+
+
+/*
+ * Architecture dependant code
+ */
+
+#ifdef CONFIG_SA1100_FRODO
+static void frodo_reset (struct net_device *dev)
+{
+	int i;
+	volatile u16 value;
+
+	/* reset ethernet controller */
+	FRODO_CPLD_ETHERNET |= FRODO_ETH_RESET;
+	mdelay (50);
+	FRODO_CPLD_ETHERNET &= ~FRODO_ETH_RESET;
+	mdelay (50);
+
+	/* we tied SBHE to CHIPSEL, so each memory access ensure the chip is in 16-bit mode */
+	for (i = 0; i < 3; i++) value = cs8900_read (dev,0);
+
+	/* FIXME: poll status bit */
+}
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+/*
+ * Driver initialization routines
+ */
+
+int __init cs8900_probe(struct net_device *dev)
+{
+	static cs8900_t priv;
+	int i,result;
+	//int rc;
+	u16 value;
+
+	printk("%s\n", version_string);
+	
+	memset (&priv,0,sizeof (cs8900_t));
+	
+/* uncomment if necessary: (if bootload doesn't provide extend memory bus initilization) */
+/*      __raw_writel(0x22111d10,S3C2410_BWSCON); */
+/*      __raw_writel(0x1f7c,S3C2410_BANKCON2); */
+
+/* from kernel 2.4: */
+/* BWSCON = (BWSCON & ~(BWSCON_ST2 | BWSCON_WS2 | BWSCON_DW2)) | */
+/*           (BWSCON_ST2 | BWSCON_WS2 | BWSCON_DW(2, BWSCON_DW_16)); */
+/*      BANKCON2= BANKCON_Tacs0 | BANKCON_Tcos4 | BANKCON_Tacc14 | */
+/*           BANKCON_Toch1 | BANKCON_Tcah4 | BANKCON_Tacp6 | BANKCON_PMC1; */
+
+	mcp = netdev_priv(dev);
+	mcp->dev = dev;
+
+	ether_setup (dev); 
+
+	dev->open               = cs8900_start;
+	dev->stop               = cs8900_stop;
+	dev->hard_start_xmit    = cs8900_send_start;
+	dev->get_stats          = cs8900_get_stats;
+	dev->set_multicast_list = cs8900_set_receive_mode;
+	dev->tx_timeout         = cs8900_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+#if defined(CONFIG_MACH_AKAE2440)
+	dev->dev_addr[0] = 0x08;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x3e;
+	dev->dev_addr[3] = 0x26;
+	dev->dev_addr[4] = 0x0a;
+	dev->dev_addr[5] = 0x5b;
+
+#else
+	dev->dev_addr[0] = 0x00;
+    	dev->dev_addr[1] = 0x12;
+    	dev->dev_addr[2] = 0x34;
+    	dev->dev_addr[3] = 0x56;
+   	dev->dev_addr[4] = 0x78;
+    	dev->dev_addr[5] = 0x9a;
+#endif
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *) &priv;
+
+	spin_lock_init(&priv.lock);
+		
+	//SET_MODULE_OWNER (dev);
+
+#ifdef CONFIG_SA1100_FRODO
+	dev->base_addr = FRODO_ETH_IO + 0x300;
+	dev->irq = FRODO_ETH_IRQ;
+	frodo_reset (dev);
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+#if defined(CONFIG_SA1100_CERF)
+	dev->base_addr = CERF_ETH_IO + 0x300;
+	dev->irq = CERF_ETH_IRQ;
+#endif /* #if defined(CONFIG_SA1100_CERF) */
+
+#if defined(CONFIG_MACH_AKAE2440)
+	dev->base_addr = 0xe0000000 + 0x300;
+	dev->irq = IRQ_EINT9;
+#endif /* #if defined(CONFIG_MACH_AKAE2440) */ 
+
+	dev_cs8900 = dev;
+
+ 	if (request_region(dev->base_addr,16,dev->name) == NULL) { 
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr); 
+ 		return (-EIO); 
+ 	} 
+
+/*	if ((result = check_mem_region (dev->base_addr, 16))) {
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr);
+		return (result);
+	}
+	request_mem_region (dev->base_addr, 16, dev->name); */
+	
+     /* verify EISA registration number for Cirrus Logic , EISA_REG_CODE is 0x630e*/
+	if ((value = cs8900_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cs8900_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	/* setup interrupt number */
+	cs8900_write (dev,PP_IntNum,0);
+
+     /* If an EEPROM is present, use it's MAC address. A valid EEPROM will 
+	 * initialize the registers automatically.
+	 */
+	result = cs8900_eeprom (dev);
+
+	printk (KERN_INFO "%s: CS8900A rev %c at %#lx irq=%d",
+		dev->name,'B' + REVISION (value) - REV_B, dev->base_addr, dev->irq);
+	if (result == -ENODEV) {
+		/* no eeprom or invalid config block, configure MAC address by hand */
+		for (i = 0; i < ETH_ALEN; i += 2)
+			cs8900_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));//这个MAC地址写到了PP_IA寄存器中，作用是地址过滤。
+		printk (", no eeprom, so write it by hand! ");
+	}
+	else if( result == -EFAULT)
+	{
+#if defined(CONFIG_SA1100_CERF)
+	    /* The default eeprom layout doesn't follow the cs8900 layout 
+		 * that enables automatic cs8900 initialization. Doh!
+		 * Read the mac address manually.
+		 */
+		u16 MAC_addr[3] = {0, 0, 0};
+
+		if (cs8900_eeprom_read(dev, &MAC_addr[0], 0x1c) == -1)
+			printk("\ncs8900: [CERF] EEPROM[0] read failed\n");
+		if (cs8900_eeprom_read(dev, &MAC_addr[1], 0x1d) == -1)
+			printk("\ncs8900: [CERF] EEPROM[1] read failed\n");
+		if (cs8900_eeprom_read(dev, &MAC_addr[2], 0x1e) == -1)
+			printk("\ncs8900: [CERF] EEPROM[2] read failed\n");
+
+		for (i = 0; i < ETH_ALEN / 2; i++)
+		{
+			dev->dev_addr[i*2]	= MAC_addr[i] & 0xff;
+			dev->dev_addr[i*2+1]	= (MAC_addr[i] >> 8) & 0xff;
+
+			cs8900_write (dev,PP_IA + i*2,dev->dev_addr[i*2] | (dev->dev_addr[i*2 + 1] << 8));
+		}
+		printk (", eeprom (smdk2410 layout)");
+#else
+		printk (", eeprom (invalid config block)");
+#endif /* #if defined(CONFIG_SA1100_CERF) */
+	}
+	else
+	{
+		printk (", eeprom ok");
+	}
+
+	printk (", addr:");
+	for (i = 0; i < ETH_ALEN; i += 2)
+	{
+		u16 mac = cs8900_read (dev,PP_IA + i);
+		printk ("%c%02X:%2X", (i==0)?' ':':', mac & 0xff, (mac >> 8));
+	}
+	printk ("\n");
+
+	return (0);
+}
+
+static int __init cs8900_init (void)
+{
+	/* 自己加的代码 */
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(*mcp));
+	if(!dev)
+	{
+		printk("unable to alloc new ethernet\n");
+		return -1;
+	}
+	dev->init = cs8900_probe;
+	strcpy(dev->name, "eth%d");
+	dev_cs8900 = dev;
+	/* 自己加的代码 */	
+
+	//return(cs8900_probe(dev));
+	return(register_netdev(dev));
+}
+
+static void __exit cs8900_cleanup (void)
+{
+	cs8900_t *priv = (cs8900_t *) dev_cs8900->priv;
+	if( priv->char_devnum)
+	{
+		unregister_chrdev(priv->char_devnum,"cs8900_eeprom");
+	}
+	
+	unregister_netdev(dev_cs8900);
+	//release_mem_region(dev_cs8900->base_addr, 16);
+	release_region(dev_cs8900->base_addr, 16);
+	free_netdev(dev_cs8900);
+	
+#ifdef CONFIG_PM
+	/* unregister power management */
+	pm_unregister(priv->pmdev);
+#endif
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham at 2d3d.co.za>");
+MODULE_DESCRIPTION (VERSION_STRING);
+MODULE_LICENSE ("GPL");
+
+module_init (cs8900_init);
+module_exit (cs8900_cleanup);
diff -urN linux-2.6.27new/drivers/net/arm/cs8900.c~ linux-2.6.27/drivers/net/arm/cs8900.c~
--- linux-2.6.27new/drivers/net/arm/cs8900.c~	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/drivers/net/arm/cs8900.c~	2009-07-23 17:19:10.000000000 +0800
@@ -0,0 +1,974 @@
+#define VERSION_STRING "Cirrus Logic CS8900A driver for Linux (Modified for SMDK2410//SMDK2440)"
+
+
+/*
+ * TODO:
+ *
+ *   1. Sort out ethernet checksum
+ *   2. If !ready in send_start(), queue buffer and send it in interrupt handler
+ *      when we receive a BufEvent with Rdy4Tx, send it again. dangerous!
+ *   3. how do we prevent interrupt handler destroying integrity of get_stats()?
+ *   4. Change reset code to check status.
+ *   5. Implement set_mac_address and remove fake mac address
+ *   7. Link status detection stuff
+ *   8. Write utility to write EEPROM, do self testing, etc.
+ *   9. Implement DMA routines (I need a board w/ DMA support for that)
+ *  10. Power management
+ *  11. Add support for multiple ethernet chips
+ */
+
+// added BSt
+//#include <linux/config.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pm.h>
+#include <linux/irq.h>
+#include <linux/fs.h>
+#include <asm/irq.h>
+//#include <asm/hardware.h>
+#include <mach/hardware.h> /* ++ */
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+// Added BSt
+#include <asm/mach-types.h>
+
+/* #include <asm/arch/regs-mem.h> */
+
+#ifdef CONFIG_ARCH_SMDK2410
+#include "asm/arch/smdk2410.h" /* ++ */
+#endif
+
+#include "cs8900.h"
+
+//#define FULL_DUPLEX
+//#define DEBUG
+//#define CONFIG_ARCH_SMDK2410
+
+static char version_string[] __initdata = "Cirrus Logic CS8900A driver for Linux (Modified for SMDK2410/SMDK2440 By Bryan Wang)";
+
+typedef struct {
+	struct net_device_stats stats;
+	u16 txlen;
+	int char_devnum;
+
+        spinlock_t lock;
+#ifdef CONFIG_PM
+    struct pm_dev *pmdev;
+#endif
+} cs8900_t;
+
+/* 自己声明一个包含struct net_device结构体指针的私有结构体 struct mycs8900_private. */
+struct mycs8900_private {
+	struct net_device *dev;
+};
+
+struct mycs8900_private *mcp;
+
+//int cs8900_probe(struct net_device *dev);
+
+static struct net_device *dev_cs8900; //保存用来unregister_netdev用的.
+
+/* 改为动态分配 */
+/*static struct net_device cs8900_dev =
+{
+        init: cs8900_probe
+};*/
+
+/* 
+ * There seems to be no way to determine the exact size of the eeprom, 
+ * so we use the largest size.
+ * FIXME: Verify it's safe to read/write past the end of a 64/128
+ *        byte eeprom. 
+ *
+ * Possible eeprom sizes: 
+ * Cx46 -  64 bytes
+ * Cx56 - 128 bytes
+ * Cx66 - 256 bytes
+ */
+#define MAX_EEPROM_SIZE		256
+
+
+static int cs8900_eeprom_fopen(struct inode *inode, struct file *file);
+static int cs8900_eeprom_frelease(struct inode *inode, struct file *file);
+static loff_t cs8900_eeprom_fllseek(struct file * file,loff_t offset, int flags);
+static ssize_t cs8900_eeprom_fread(struct file *file, char *buf, size_t count, loff_t *f_pos);
+static ssize_t cs8900_eeprom_fwrite(struct file *file, const char *buf, size_t count, loff_t *f_pos);
+static struct file_operations cs8900_eeprom_fops = {
+        .owner    =     THIS_MODULE,
+        .open     =     cs8900_eeprom_fopen,
+        .release  =     cs8900_eeprom_frelease,
+        .llseek   =     cs8900_eeprom_fllseek,
+        .read     =     cs8900_eeprom_fread,
+        .write    =     cs8900_eeprom_fwrite,
+};      
+
+static u16 cs8900_eeprom_cache[MAX_EEPROM_SIZE/2];
+
+/*
+ * I/O routines
+ */
+
+static inline u16 cs8900_read (struct net_device *dev,u16 reg)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	return (inw (dev->base_addr + PP_Data));
+}
+
+static inline void cs8900_write (struct net_device *dev,u16 reg,u16 value)
+{
+	outw (reg,dev->base_addr + PP_Address);
+	outw (value,dev->base_addr + PP_Data);
+}
+
+static inline void cs8900_set (struct net_device *dev,u16 reg,u16 value)
+{
+	cs8900_write (dev,reg,cs8900_read (dev,reg) | value);
+}
+
+static inline void cs8900_clear (struct net_device *dev,u16 reg,u16 value)
+{
+	cs8900_write (dev,reg,cs8900_read (dev,reg) & ~value);
+}
+
+static inline void cs8900_frame_read (struct net_device *dev,struct sk_buff *skb,u16 length)
+{
+	insw (dev->base_addr,skb_put (skb,length),(length + 1) / 2);
+}
+
+static inline void cs8900_frame_write (struct net_device *dev,struct sk_buff *skb)
+{
+	outsw (dev->base_addr,skb->data,(skb->len + 1) / 2);
+}
+
+
+/*
+ * EEPROM I/O routines
+ */
+
+static int cs8900_eeprom_wait (struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; i < 3000; i++) {
+		if (!(cs8900_read (dev,PP_SelfST) & SIBUSY))
+			return (0);
+		udelay (1);
+	}
+
+	return (-1);
+}
+
+static int cs8900_eeprom_read (struct net_device *dev,u16 *value,u16 offset)
+{
+	if (cs8900_eeprom_wait (dev) < 0)
+		return (-1);
+
+	cs8900_write (dev,PP_EEPROMCommand,offset | EEReadRegister);
+
+	if (cs8900_eeprom_wait (dev) < 0)
+		return (-1);
+
+	*value = cs8900_read (dev,PP_EEPROMData);
+
+	return (0);
+}
+
+static int cs8900_eeprom_write (struct net_device *dev,u16 *value,u16 offset)
+{
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (EEWriteEnable));
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMData, *value);
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (offset | EEWriteRegister));
+	cs8900_eeprom_wait(dev);
+        cs8900_write(dev, PP_EEPROMCommand, (EEWriteDisable));
+	cs8900_eeprom_wait(dev);
+
+        return 0;
+}
+
+/*
+ * Debugging functions
+ */
+
+#ifdef DEBUG
+static inline int printable (int c)
+{
+	return ((c >= 32 && c <= 126) ||
+			(c >= 174 && c <= 223) ||
+			(c >= 242 && c <= 243) ||
+			(c >= 252 && c <= 253));
+}
+
+static void dump16 (struct net_device *dev,const u8 *s,size_t len)
+{
+	int i;
+	char str[128];
+
+	if (!len) return;
+
+	*str = '\0';
+
+	for (i = 0; i < len; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		sprintf (str,"%s%.2x ",str,s[i]);
+	}
+
+	for ( ; i < 16; i++) {
+		if (i && !(i % 4)) strcat (str," ");
+		strcat (str,"   ");
+	}
+
+	strcat (str," ");
+	for (i = 0; i < len; i++) sprintf (str,"%s%c",str,printable (s[i]) ? s[i] : '.');
+
+	printk (KERN_DEBUG "%s:     %s\n",dev->name,str);
+}
+
+static void hexdump (struct net_device *dev,const void *ptr,size_t size)
+{
+	const u8 *s = (u8 *) ptr;
+	int i;
+	for (i = 0; i < size / 16; i++, s += 16) dump16 (dev,s,16);
+	dump16 (dev,s,size % 16);
+}
+
+static void dump_packet (struct net_device *dev,struct sk_buff *skb,const char *type)
+{
+	printk (KERN_INFO "%s: %s %d byte frame %.2x:%.2x:%.2x:%.2x:%.2x:%.2x to %.2x:%.2x:%.2x:%.2x:%.2x:%.2x type %.4x\n",
+			dev->name,
+			type,
+			skb->len,
+			skb->data[0],skb->data[1],skb->data[2],skb->data[3],skb->data[4],skb->data[5],
+			skb->data[6],skb->data[7],skb->data[8],skb->data[9],skb->data[10],skb->data[11],
+			(skb->data[12] << 8) | skb->data[13]);
+	if (skb->len < 0x100) hexdump (dev,skb->data,skb->len);
+}
+
+static void eepromdump( struct net_device *dev)
+{
+	u16 buf[0x80];
+	u16 i;
+	int count;
+	int total;
+
+	if( cs8900_read( dev, PP_SelfST) & EEPROMpresent)
+	{
+		printk (KERN_INFO "%s: EEPROM present\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: NO EEPROM present\n",dev->name);
+		return;
+	}
+
+	if( cs8900_read( dev, PP_SelfST) & EEPROMOK)
+	{
+		printk (KERN_INFO "%s: EEPROM OK\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: EEPROM checksum mismatch - fixing...\n",dev->name);
+	}
+
+	printk (KERN_INFO "%s: Hexdump\n",dev->name);
+	for( i=0; i<0x80; i++)
+	{
+		cs8900_eeprom_read( dev, &buf[i], i);
+	}
+	hexdump( dev, buf, 0x100);
+
+	if( buf[0] & 0x0100)
+	{
+		printk (KERN_INFO "%s: non-sequential EEPROM\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: sequential EEPROM\n",dev->name);
+	}
+
+	if( (buf[0] & 0xe000) == 0xa000)
+	{
+		printk (KERN_INFO "%s: Found reset configuration block\n",dev->name);
+	}
+	else
+	{
+		printk (KERN_INFO "%s: Reset configuration block not found\n",dev->name);
+		return;
+	}
+
+	count = 2;
+	total = buf[0] & 0xff;
+	printk (KERN_INFO "%s: Reset configuration block size = %d bytes\n",dev->name, total);
+
+	while( count < total)
+	{
+		int groupsize = (buf[count/2] >> 12) + 1;
+		int basereg = (buf[count/2] &0x1ff);
+		printk (KERN_INFO "%s: Group size = %d words\n",dev->name, groupsize);
+		printk (KERN_INFO "%s:  Base register = %x\n",dev->name, basereg);
+		count += (groupsize + 1)*2;
+	}
+}
+
+#endif	/* #ifdef DEBUG */
+
+/*
+ * Driver functions
+ */
+
+static void cs8900_receive (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	struct sk_buff *skb;
+	u16 status,length;
+
+	status = cs8900_read (dev,PP_RxStatus);
+	length = cs8900_read (dev,PP_RxLength);
+
+	if (!(status & RxOK)) {
+		priv->stats.rx_errors++;
+		if ((status & (Runt | Extradata))) priv->stats.rx_length_errors++;
+		if ((status & CRCerror)) priv->stats.rx_crc_errors++;
+		return;
+	}
+
+	if ((skb = dev_alloc_skb (length + 2)) == NULL) { 
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb->dev = dev;
+	skb_reserve (skb,2);
+
+	cs8900_frame_read (dev,skb,length);
+
+//#ifdef FULL_DUPLEX
+#ifdef DEBUG
+	dump_packet (dev,skb,"recv");
+#endif	/* #ifdef FULL_DUPLEX */
+
+	skb->protocol = eth_type_trans (skb,dev); 
+
+	netif_rx (skb);
+	dev->last_rx = jiffies;
+
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += length;
+}
+
+static int cs8900_send_start (struct sk_buff *skb,struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	u16 status;
+
+	spin_lock_irq(&priv->lock);
+	netif_stop_queue (dev); 
+
+	cs8900_write (dev,PP_TxCMD,TxStart (After5)); 
+	cs8900_write (dev,PP_TxLength,skb->len); 
+
+	status = cs8900_read (dev,PP_BusST);
+
+	if ((status & TxBidErr)) {
+		spin_unlock_irq(&priv->lock);
+		printk (KERN_WARNING "%s: Invalid frame size %d!\n",dev->name,skb->len);
+		priv->stats.tx_errors++;
+		priv->stats.tx_aborted_errors++;
+		priv->txlen = 0;
+		return (1);
+	}
+
+	if (!(status & Rdy4TxNOW)) {
+		spin_unlock_irq(&priv->lock);
+		printk (KERN_WARNING "%s: Transmit buffer not free!\n",dev->name);
+		priv->stats.tx_errors++;
+		priv->txlen = 0;
+		/* FIXME: store skb and send it in interrupt handler */
+		return (1);
+	}
+
+	cs8900_frame_write (dev,skb); 
+	spin_unlock_irq(&priv->lock);
+
+#ifdef DEBUG
+	dump_packet (dev,skb,"send");
+#endif	/* #ifdef DEBUG */
+
+	dev->trans_start = jiffies;
+
+	dev_kfree_skb (skb);
+
+	priv->txlen = skb->len;
+
+	return (0);
+}
+
+//static irqreturn_t cs8900_interrupt (int irq,void *id,struct pt_regs *regs)
+static irqreturn_t cs8900_interrupt (int irq,void *id) /* ++ */
+{
+	struct net_device *dev = (struct net_device *) id;
+	cs8900_t *priv;
+	volatile u16 status;
+     irqreturn_t handled = 0;
+
+	if (dev->priv == NULL) {
+		printk (KERN_WARNING "%s: irq %d for unknown device.\n",dev->name,irq);
+		return 0;
+	}
+
+	priv = (cs8900_t *) dev->priv;
+	
+	while ((status = cs8900_read (dev, PP_ISQ))) {
+		handled = 1;
+		switch (RegNum (status)) {
+		case RxEvent:
+			cs8900_receive (dev);
+			break;
+
+		case TxEvent:
+			priv->stats.collisions += ColCount (cs8900_read (dev,PP_TxCOL));
+			if (!(RegContent (status) & TxOK)) {
+				priv->stats.tx_errors++;
+				if ((RegContent (status) & Out_of_window)) priv->stats.tx_window_errors++;
+				if ((RegContent (status) & Jabber)) priv->stats.tx_aborted_errors++;
+				break;
+			} else if (priv->txlen) {
+				priv->stats.tx_packets++;
+				priv->stats.tx_bytes += priv->txlen;
+			}
+			priv->txlen = 0;
+			netif_wake_queue (dev);
+			break;
+
+		case BufEvent:
+			if ((RegContent (status) & RxMiss)) {
+				u16 missed = MissCount (cs8900_read (dev,PP_RxMISS));
+				priv->stats.rx_errors += missed;
+				priv->stats.rx_missed_errors += missed;
+			}
+			if ((RegContent (status) & TxUnderrun)) {
+				priv->stats.tx_errors++;
+				priv->stats.tx_fifo_errors++;
+
+				priv->txlen = 0;
+				netif_wake_queue (dev);
+			}
+			/* FIXME: if Rdy4Tx, transmit last sent packet (if any) */
+			break;
+
+		case TxCOL:
+			priv->stats.collisions += ColCount (cs8900_read (dev,PP_TxCOL));
+			break;
+
+		case RxMISS:
+			status = MissCount (cs8900_read (dev,PP_RxMISS));
+			priv->stats.rx_errors += status;
+			priv->stats.rx_missed_errors += status;
+			break;
+		}
+	}
+	return IRQ_RETVAL(handled);
+}
+
+static void cs8900_transmit_timeout (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	priv->stats.tx_errors++;
+	priv->stats.tx_heartbeat_errors++;
+	priv->txlen = 0;
+	netif_wake_queue (dev);
+}
+
+static int cs8900_start (struct net_device *dev)
+{
+	int result;
+
+#if defined(CONFIG_MACH_AKAE2440)
+	set_irq_type(dev->irq, IRQF_TRIGGER_RISING);
+
+	/* enable the ethernet controller */
+	cs8900_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cs8900_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cs8900_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cs8900_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cs8900_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cs8900_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cs8900_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+	udelay(200);	
+	/* install interrupt handler */
+	if ((result = request_irq (dev->irq, &cs8900_interrupt, 0, dev->name, dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name, dev->irq);
+		return (result);
+	}
+#else
+	
+	/* install interrupt handler */
+	if ((result = request_irq (dev->irq, &cs8900_interrupt, 0, dev->name, dev)) < 0) {
+		printk (KERN_ERR "%s: could not register interrupt %d\n",dev->name, dev->irq);
+		return (result);
+	}
+
+	set_irq_type(dev->irq, IRQF_TRIGGER_RISING);
+
+	/* enable the ethernet controller */
+	cs8900_set (dev,PP_RxCFG,RxOKiE | BufferCRC | CRCerroriE | RuntiE | ExtradataiE);
+	cs8900_set (dev,PP_RxCTL,RxOKA | IndividualA | BroadcastA);
+	cs8900_set (dev,PP_TxCFG,TxOKiE | Out_of_windowiE | JabberiE);
+	cs8900_set (dev,PP_BufCFG,Rdy4TxiE | RxMissiE | TxUnderruniE | TxColOvfiE | MissOvfloiE);
+	cs8900_set (dev,PP_LineCTL,SerRxON | SerTxON);
+	cs8900_set (dev,PP_BusCTL,EnableRQ);
+
+#ifdef FULL_DUPLEX
+	cs8900_set (dev,PP_TestCTL,FDX);
+#endif	/* #ifdef FULL_DUPLEX */
+	
+#endif /* #if defined(CONFIG_MACH_AKAE2440) */
+
+	/* start the queue */
+	netif_start_queue (dev);
+
+	return (0);
+}
+
+static int cs8900_stop (struct net_device *dev)
+{
+	/* disable ethernet controller */
+	cs8900_write (dev,PP_BusCTL,0);
+	cs8900_write (dev,PP_TestCTL,0);
+	cs8900_write (dev,PP_SelfCTL,0);
+	cs8900_write (dev,PP_LineCTL,0);
+	cs8900_write (dev,PP_BufCFG,0);
+	cs8900_write (dev,PP_TxCFG,0);
+	cs8900_write (dev,PP_RxCTL,0);
+	cs8900_write (dev,PP_RxCFG,0);
+
+	/* uninstall interrupt handler */
+	free_irq (dev->irq,dev);
+
+	/* stop the queue */
+	netif_stop_queue (dev);
+
+	return (0);
+}
+
+static struct net_device_stats *cs8900_get_stats (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	return (&priv->stats);
+}
+
+static void cs8900_set_receive_mode (struct net_device *dev)
+{
+	if ((dev->flags & IFF_PROMISC))
+		cs8900_set (dev,PP_RxCTL,PromiscuousA);
+	else
+		cs8900_clear (dev,PP_RxCTL,PromiscuousA);
+
+	if ((dev->flags & IFF_ALLMULTI) && dev->mc_list)
+		cs8900_set (dev,PP_RxCTL,MulticastA);
+	else
+		cs8900_clear (dev,PP_RxCTL,MulticastA);
+}
+
+static int cs8900_eeprom (struct net_device *dev)
+{
+	cs8900_t *priv = (cs8900_t *) dev->priv;
+	int i;
+
+	/* SMDK2410 CS8900A without EEPROM at all */
+#if defined(CONFIG_MACH_AKAE2440)
+	return (-ENODEV);
+#endif 
+
+#ifdef DEBUG
+	eepromdump (dev);
+#endif
+
+	if( (cs8900_read( dev, PP_SelfST) & EEPROMpresent) == 0)
+	{
+		/* no eeprom */
+		return (-ENODEV);
+	}
+
+	/* add character device for easy eeprom programming */
+	if( (priv->char_devnum=register_chrdev(0,"cs8900_eeprom",&cs8900_eeprom_fops)) != 0)
+		printk (KERN_INFO "%s: Registered cs8900_eeprom char device (major #%d)\n",
+			dev->name, priv->char_devnum);
+	else
+		printk (KERN_WARNING "%s: Failed to register char device cs8900_eeprom\n",dev->name);
+
+	if( (cs8900_read( dev, PP_SelfST) & EEPROMOK) == 0) 
+	{
+		/* bad checksum, invalid config block */
+		return (-EFAULT);
+	}
+
+	/* If we get here, the chip will have initialized the registers
+	 * that were specified in the eeprom configuration block
+	 * We assume this is at least the mac address.
+	 */
+	for (i = 0; i < ETH_ALEN; i += 2)
+	{
+		u16 mac = cs8900_read (dev,PP_IA + i);
+		dev->dev_addr[i] = mac & 0xff;
+		dev->dev_addr[i+1] = (mac>>8) & 0xff;
+	}
+
+	return (0);
+}
+
+/*
+ * EEPROM Charater device
+ */
+
+static int cs8900_eeprom_fopen(struct inode *inode, struct file *file)
+{
+	u16 i;
+	for( i=0; i<MAX_EEPROM_SIZE/2; i++)
+	{
+		cs8900_eeprom_read( dev_cs8900, &cs8900_eeprom_cache[i],i);
+	}
+
+	return 0;
+}
+
+static int cs8900_eeprom_frelease(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static loff_t cs8900_eeprom_fllseek(struct file * file,loff_t offset, int whence)
+{
+	long newpos;
+
+	switch(whence)
+	{
+		case 0: /* SEEK_SET */
+			newpos = offset;
+			break;
+		case 1: /* SEEK_CUR */
+			newpos = file->f_pos + offset;
+			break;
+		case 2: /* SEEK_END */
+			newpos = (MAX_EEPROM_SIZE-1) - offset;
+			break;
+		default: /* can't happen */
+			return -EINVAL;
+
+	}
+
+	if( (newpos<0) || (newpos>=MAX_EEPROM_SIZE)) return -EINVAL;
+
+	file->f_pos = newpos;
+	return newpos;
+}
+
+static ssize_t cs8900_eeprom_fread(struct file *file, char *buf, size_t count, loff_t *f_pos)
+{
+	unsigned char *temp = (unsigned char *)cs8900_eeprom_cache;
+
+        if (*f_pos >= MAX_EEPROM_SIZE)
+                return 0;
+
+        if (*f_pos + count > MAX_EEPROM_SIZE)
+            count = MAX_EEPROM_SIZE - *f_pos;
+
+        if (count<1)
+                return 0;
+
+        if (copy_to_user(buf, &temp[*f_pos], count)){
+                return -EFAULT;
+        }
+        *f_pos += count;
+        return count;
+}
+
+static ssize_t cs8900_eeprom_fwrite(struct file *file, const char *buf, size_t count, loff_t *f_pos)
+{
+	u16 i;
+	unsigned char *temp = (unsigned char *)cs8900_eeprom_cache;
+
+        if (*f_pos >= MAX_EEPROM_SIZE)
+                return 0;
+
+        if (*f_pos + count > MAX_EEPROM_SIZE)
+            count = MAX_EEPROM_SIZE - *f_pos;
+
+        if (count<1)
+                return 0;
+
+	/* FIXME: lock critical section */
+
+	/* update the cache */
+        if (copy_from_user(&temp[*f_pos], buf, count)){
+                return -EFAULT;
+        }
+
+	/* not concerned about performance, so write the entire thing */
+	for( i=0; i<MAX_EEPROM_SIZE/2; i++)
+	{
+		cs8900_eeprom_write( dev_cs8900, &cs8900_eeprom_cache[i],i);
+	}
+
+        *f_pos += count;
+        return count;
+}
+
+
+/*
+ * Architecture dependant code
+ */
+
+#ifdef CONFIG_SA1100_FRODO
+static void frodo_reset (struct net_device *dev)
+{
+	int i;
+	volatile u16 value;
+
+	/* reset ethernet controller */
+	FRODO_CPLD_ETHERNET |= FRODO_ETH_RESET;
+	mdelay (50);
+	FRODO_CPLD_ETHERNET &= ~FRODO_ETH_RESET;
+	mdelay (50);
+
+	/* we tied SBHE to CHIPSEL, so each memory access ensure the chip is in 16-bit mode */
+	for (i = 0; i < 3; i++) value = cs8900_read (dev,0);
+
+	/* FIXME: poll status bit */
+}
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+/*
+ * Driver initialization routines
+ */
+
+int __init cs8900_probe(struct net_device *dev)
+{
+	static cs8900_t priv;
+	int i,result;
+	//int rc;
+	u16 value;
+
+	printk("%s\n", version_string);
+	//printk (VERSION_STRING"\n");
+	
+	memset (&priv,0,sizeof (cs8900_t));
+	
+/* uncomment if necessary: (if bootload doesn't provide extend memory bus initilization) */
+/*      __raw_writel(0x22111d10,S3C2410_BWSCON); */
+/*      __raw_writel(0x1f7c,S3C2410_BANKCON2); */
+
+/* from kernel 2.4: */
+/* BWSCON = (BWSCON & ~(BWSCON_ST2 | BWSCON_WS2 | BWSCON_DW2)) | */
+/*           (BWSCON_ST2 | BWSCON_WS2 | BWSCON_DW(2, BWSCON_DW_16)); */
+/*      BANKCON2= BANKCON_Tacs0 | BANKCON_Tcos4 | BANKCON_Tacc14 | */
+/*           BANKCON_Toch1 | BANKCON_Tcah4 | BANKCON_Tacp6 | BANKCON_PMC1; */
+
+	mcp = netdev_priv(dev);
+	mcp->dev = dev;
+	//strcpy(dev->name, "eth%d");//注册之前必须要有这个语句，给网卡设备一个名字。
+
+	ether_setup (dev); 
+
+	dev->open               = cs8900_start;
+	dev->stop               = cs8900_stop;
+	dev->hard_start_xmit    = cs8900_send_start;
+	dev->get_stats          = cs8900_get_stats;
+	dev->set_multicast_list = cs8900_set_receive_mode;
+	dev->tx_timeout         = cs8900_transmit_timeout;
+	dev->watchdog_timeo     = HZ;
+
+	//可以在模块入口函数里注册，也可以在dev->init函数里注册（也就是这里）。
+	/*rc = register_netdev(dev);
+	if (rc < 0)
+	{
+		printk("can not register net_device!\n");
+		return -1;
+	}*/
+
+#if defined(CONFIG_MACH_AKAE2440)
+	dev->dev_addr[0] = 0x08;
+	dev->dev_addr[1] = 0x00;
+	dev->dev_addr[2] = 0x3e;
+	dev->dev_addr[3] = 0x26;
+	dev->dev_addr[4] = 0x0a;
+	dev->dev_addr[5] = 0x5b;
+
+#else
+	dev->dev_addr[0] = 0x00;
+    	dev->dev_addr[1] = 0x12;
+    	dev->dev_addr[2] = 0x34;
+    	dev->dev_addr[3] = 0x56;
+   	dev->dev_addr[4] = 0x78;
+    	dev->dev_addr[5] = 0x9a;
+#endif
+
+	dev->if_port   = IF_PORT_10BASET;
+	dev->priv      = (void *) &priv;
+
+	spin_lock_init(&priv.lock);
+		
+	//SET_MODULE_OWNER (dev);
+
+#ifdef CONFIG_SA1100_FRODO
+	dev->base_addr = FRODO_ETH_IO + 0x300;
+	dev->irq = FRODO_ETH_IRQ;
+	frodo_reset (dev);
+#endif	/* #ifdef CONFIG_SA1100_FRODO */
+
+#if defined(CONFIG_SA1100_CERF)
+	dev->base_addr = CERF_ETH_IO + 0x300;
+	dev->irq = CERF_ETH_IRQ;
+#endif /* #if defined(CONFIG_SA1100_CERF) */
+
+#if defined(CONFIG_MACH_AKAE2440)
+	dev->base_addr = 0xe0000000 + 0x300;
+	dev->irq = IRQ_EINT9;
+#endif /* #if defined(CONFIG_MACH_AKAE2440) */ 
+
+	dev_cs8900 = dev;
+
+ 	if (request_region(dev->base_addr,16,dev->name) == NULL) { 
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr); 
+ 		return (-EIO); 
+ 	} 
+
+/*	if ((result = check_mem_region (dev->base_addr, 16))) {
+		printk (KERN_ERR "%s: can't get I/O port address 0x%lx\n",dev->name,dev->base_addr);
+		return (result);
+	}
+	request_mem_region (dev->base_addr, 16, dev->name); */
+	
+     /* verify EISA registration number for Cirrus Logic , EISA_REG_CODE is 0x630e*/
+	if ((value = cs8900_read (dev,PP_ProductID)) != EISA_REG_CODE) {
+		printk (KERN_ERR "%s: incorrect signature 0x%.4x\n",dev->name,value);
+		return (-ENXIO);
+	}
+
+	/* verify chip version */
+	value = cs8900_read (dev,PP_ProductID + 2);
+	if (VERSION (value) != CS8900A) {
+		printk (KERN_ERR "%s: unknown chip version 0x%.8x\n",dev->name,VERSION (value));
+		return (-ENXIO);
+	}
+	/* setup interrupt number */
+	cs8900_write (dev,PP_IntNum,0);
+
+     /* If an EEPROM is present, use it's MAC address. A valid EEPROM will 
+	 * initialize the registers automatically.
+	 */
+	result = cs8900_eeprom (dev);
+
+	printk (KERN_INFO "%s: CS8900A rev %c at %#lx irq=%d",
+		dev->name,'B' + REVISION (value) - REV_B, dev->base_addr, dev->irq);
+	if (result == -ENODEV) {
+		/* no eeprom or invalid config block, configure MAC address by hand */
+		for (i = 0; i < ETH_ALEN; i += 2)
+			cs8900_write (dev,PP_IA + i,dev->dev_addr[i] | (dev->dev_addr[i + 1] << 8));//这个MAC地址写到了PP_IA寄存器中，作用是地址过滤。
+		printk (", no eeprom, so write it by hand! ");
+	}
+	else if( result == -EFAULT)
+	{
+#if defined(CONFIG_SA1100_CERF)
+	    /* The default eeprom layout doesn't follow the cs8900 layout 
+		 * that enables automatic cs8900 initialization. Doh!
+		 * Read the mac address manually.
+		 */
+		u16 MAC_addr[3] = {0, 0, 0};
+
+		if (cs8900_eeprom_read(dev, &MAC_addr[0], 0x1c) == -1)
+			printk("\ncs8900: [CERF] EEPROM[0] read failed\n");
+		if (cs8900_eeprom_read(dev, &MAC_addr[1], 0x1d) == -1)
+			printk("\ncs8900: [CERF] EEPROM[1] read failed\n");
+		if (cs8900_eeprom_read(dev, &MAC_addr[2], 0x1e) == -1)
+			printk("\ncs8900: [CERF] EEPROM[2] read failed\n");
+
+		for (i = 0; i < ETH_ALEN / 2; i++)
+		{
+			dev->dev_addr[i*2]	= MAC_addr[i] & 0xff;
+			dev->dev_addr[i*2+1]	= (MAC_addr[i] >> 8) & 0xff;
+
+			cs8900_write (dev,PP_IA + i*2,dev->dev_addr[i*2] | (dev->dev_addr[i*2 + 1] << 8));
+		}
+		printk (", eeprom (smdk2410 layout)");
+#else
+		printk (", eeprom (invalid config block)");
+#endif /* #if defined(CONFIG_SA1100_CERF) */
+	}
+	else
+	{
+		printk (", eeprom ok");
+	}
+
+	printk (", addr:");
+	for (i = 0; i < ETH_ALEN; i += 2)
+	{
+		u16 mac = cs8900_read (dev,PP_IA + i);
+		printk ("%c%02X:%2X", (i==0)?' ':':', mac & 0xff, (mac >> 8));
+	}
+	printk ("\n");
+
+	return (0);
+}
+
+static int __init cs8900_init (void)
+{
+	/* 自己加的代码 */
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(*mcp));
+	if(!dev)
+	{
+		printk("unable to alloc new ethernet\n");
+		return -1;
+	}
+	dev->init = cs8900_probe;
+	strcpy(dev->name, "eth%d");
+	dev_cs8900 = dev;
+	/* 自己加的代码 */	
+
+	//return(cs8900_probe(dev));
+	return(register_netdev(dev));
+}
+
+static void __exit cs8900_cleanup (void)
+{
+	cs8900_t *priv = (cs8900_t *) dev_cs8900->priv;
+	if( priv->char_devnum)
+	{
+		unregister_chrdev(priv->char_devnum,"cs8900_eeprom");
+	}
+	
+	unregister_netdev(dev_cs8900);
+	//release_mem_region(dev_cs8900->base_addr, 16);
+	release_region(dev_cs8900->base_addr, 16);
+	free_netdev(dev_cs8900);
+	
+#ifdef CONFIG_PM
+	/* unregister power management */
+	pm_unregister(priv->pmdev);
+#endif
+}
+
+MODULE_AUTHOR ("Abraham van der Merwe <abraham at 2d3d.co.za>");
+MODULE_DESCRIPTION (VERSION_STRING);
+MODULE_LICENSE ("GPL");
+
+module_init (cs8900_init);
+module_exit (cs8900_cleanup);
diff -urN linux-2.6.27new/drivers/net/arm/cs8900.h linux-2.6.27/drivers/net/arm/cs8900.h
--- linux-2.6.27new/drivers/net/arm/cs8900.h	1970-01-01 08:00:00.000000000 +0800
+++ linux-2.6.27/drivers/net/arm/cs8900.h	2008-11-22 10:14:28.000000000 +0800
@@ -0,0 +1,237 @@
+#ifndef CS8900_H
+#define CS8900_H
+
+/*
+ * linux/drivers/net/cs8900.h
+ *
+ * Author: Abraham van der Merwe <abraham at 2d3d.co.za>
+ *
+ * A Cirrus Logic CS8900A driver for Linux
+ * based on the cs89x0 driver written by Russell Nelson,
+ * Donald Becker, and others.
+ *
+ * This source code is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+/*
+ * Ports
+ */
+
+#define PP_Address		0x0a	/* PacketPage Pointer Port (Section 4.10.10) */
+#define PP_Data			0x0c	/* PacketPage Data Port (Section 4.10.10) */
+
+/*
+ * Registers
+ */
+
+#define PP_ProductID		0x0000	/* Section 4.3.1   Product Identification Code */
+#define PP_MemBase			0x002c	/* Section 4.9.2   Memory Base Address Register */
+#define PP_IntNum			0x0022	/* Section 3.2.3   Interrupt Number */
+#define PP_EEPROMCommand	0x0040	/* Section 4.3.11  EEPROM Command */
+#define PP_EEPROMData		0x0042	/* Section 4.3.12  EEPROM Data */
+#define PP_RxCFG			0x0102	/* Section 4.4.6   Receiver Configuration */
+#define PP_RxCTL			0x0104	/* Section 4.4.8   Receiver Control */
+#define PP_TxCFG			0x0106	/* Section 4.4.9   Transmit Configuration */
+#define PP_BufCFG			0x010a	/* Section 4.4.12  Buffer Configuration */
+#define PP_LineCTL			0x0112	/* Section 4.4.16  Line Control */
+#define PP_SelfCTL			0x0114	/* Section 4.4.18  Self Control */
+#define PP_BusCTL			0x0116	/* Section 4.4.20  Bus Control */
+#define PP_TestCTL			0x0118	/* Section 4.4.22  Test Control */
+#define PP_ISQ				0x0120	/* Section 4.4.5   Interrupt Status Queue */
+#define PP_TxEvent			0x0128	/* Section 4.4.10  Transmitter Event */
+#define PP_BufEvent			0x012c	/* Section 4.4.13  Buffer Event */
+#define PP_RxMISS			0x0130	/* Section 4.4.14  Receiver Miss Counter */
+#define PP_TxCOL			0x0132	/* Section 4.4.15  Transmit Collision Counter */
+#define PP_SelfST			0x0136	/* Section 4.4.19  Self Status */
+#define PP_BusST			0x0138	/* Section 4.4.21  Bus Status */
+#define PP_TxCMD			0x0144	/* Section 4.4.11  Transmit Command */
+#define PP_TxLength			0x0146	/* Section 4.5.2   Transmit Length */
+#define PP_IA				0x0158	/* Section 4.6.2   Individual Address (IEEE Address) */
+#define PP_RxStatus			0x0400	/* Section 4.7.1   Receive Status */
+#define PP_RxLength			0x0402	/* Section 4.7.1   Receive Length (in bytes) */
+#define PP_RxFrame			0x0404	/* Section 4.7.2   Receive Frame Location */
+#define PP_TxFrame			0x0a00	/* Section 4.7.2   Transmit Frame Location */
+
+/*
+ * Values
+ */
+
+/* PP_IntNum */
+#define INTRQ0			0x0000
+#define INTRQ1			0x0001
+#define INTRQ2			0x0002
+#define INTRQ3			0x0003
+
+/* PP_ProductID */
+#define EISA_REG_CODE	0x630e
+#define REVISION(x)		(((x) & 0x1f00) >> 8)
+#define VERSION(x)		((x) & ~0x1f00)
+
+#define CS8900A			0x0000
+#define REV_B			7
+#define REV_C			8
+#define REV_D			9
+
+/* PP_RxCFG */
+#define Skip_1			0x0040
+#define StreamE			0x0080
+#define RxOKiE			0x0100
+#define RxDMAonly		0x0200
+#define AutoRxDMAE		0x0400
+#define BufferCRC		0x0800
+#define CRCerroriE		0x1000
+#define RuntiE			0x2000
+#define ExtradataiE		0x4000
+
+/* PP_RxCTL */
+#define IAHashA			0x0040
+#define PromiscuousA	0x0080
+#define RxOKA			0x0100
+#define MulticastA		0x0200
+#define IndividualA		0x0400
+#define BroadcastA		0x0800
+#define CRCerrorA		0x1000
+#define RuntA			0x2000
+#define ExtradataA		0x4000
+
+/* PP_TxCFG */
+#define Loss_of_CRSiE	0x0040
+#define SQErroriE		0x0080
+#define TxOKiE			0x0100
+#define Out_of_windowiE	0x0200
+#define JabberiE		0x0400
+#define AnycolliE		0x0800
+#define T16colliE		0x8000
+
+/* PP_BufCFG */
+#define SWint_X			0x0040
+#define RxDMAiE			0x0080
+#define Rdy4TxiE		0x0100
+#define TxUnderruniE	0x0200
+#define RxMissiE		0x0400
+#define Rx128iE			0x0800
+#define TxColOvfiE		0x1000
+#define MissOvfloiE		0x2000
+#define RxDestiE		0x8000
+
+/* PP_LineCTL */
+#define SerRxON			0x0040
+#define SerTxON			0x0080
+#define AUIonly			0x0100
+#define AutoAUI_10BT	0x0200
+#define ModBackoffE		0x0800
+#define PolarityDis		0x1000
+#define L2_partDefDis	0x2000
+#define LoRxSquelch		0x4000
+
+/* PP_SelfCTL */
+#define RESET			0x0040
+#define SWSuspend		0x0100
+#define HWSleepE		0x0200
+#define HWStandbyE		0x0400
+#define HC0E			0x1000
+#define HC1E			0x2000
+#define HCB0			0x4000
+#define HCB1			0x8000
+
+/* PP_BusCTL */
+#define ResetRxDMA		0x0040
+#define DMAextend		0x0100
+#define UseSA			0x0200
+#define MemoryE			0x0400
+#define DMABurst		0x0800
+#define IOCHRDYE		0x1000
+#define RxDMAsize		0x2000
+#define EnableRQ		0x8000
+
+/* PP_TestCTL */
+#define DisableLT		0x0080
+#define ENDECloop		0x0200
+#define AUIloop			0x0400
+#define DisableBackoff	0x0800
+#define FDX				0x4000
+
+/* PP_ISQ */
+#define RegNum(x) ((x) & 0x3f)
+#define RegContent(x) ((x) & ~0x3d)
+
+#define RxEvent			0x0004
+#define TxEvent			0x0008
+#define BufEvent		0x000c
+#define RxMISS			0x0010
+#define TxCOL			0x0012
+
+/* PP_RxStatus */
+#define IAHash			0x0040
+#define Dribblebits		0x0080
+#define RxOK			0x0100
+#define Hashed			0x0200
+#define IndividualAdr	0x0400
+#define Broadcast		0x0800
+#define CRCerror		0x1000
+#define Runt			0x2000
+#define Extradata		0x4000
+
+#define HashTableIndex(x) ((x) >> 0xa)
+
+/* PP_TxCMD */
+#define After5			0
+#define After381		1
+#define After1021		2
+#define AfterAll		3
+#define TxStart(x) ((x) << 6)
+
+#define Force			0x0100
+#define Onecoll			0x0200
+#define InhibitCRC		0x1000
+#define TxPadDis		0x2000
+
+/* PP_BusST */
+#define TxBidErr		0x0080
+#define Rdy4TxNOW		0x0100
+
+/* PP_TxEvent */
+#define Loss_of_CRS		0x0040
+#define SQEerror		0x0080
+#define TxOK			0x0100
+#define Out_of_window	0x0200
+#define Jabber			0x0400
+#define T16coll			0x8000
+
+#define TX_collisions(x) (((x) >> 0xb) & ~0x8000)
+
+/* PP_BufEvent */
+#define SWint			0x0040
+#define RxDMAFrame		0x0080
+#define Rdy4Tx			0x0100
+#define TxUnderrun		0x0200
+#define RxMiss			0x0400
+#define Rx128			0x0800
+#define RxDest			0x8000
+
+/* PP_RxMISS */
+#define MissCount(x) ((x) >> 6)
+
+/* PP_TxCOL */
+#define ColCount(x) ((x) >> 6)
+
+/* PP_SelfST */
+#define T3VActive		0x0040
+#define INITD			0x0080
+#define SIBUSY			0x0100
+#define EEPROMpresent	0x0200
+#define EEPROMOK		0x0400
+#define ELpresent		0x0800
+#define EEsize			0x1000
+
+/* PP_EEPROMCommand */
+#define EEWriteEnable   0x00F0
+#define EEWriteDisable  0x0000
+#define EEWriteRegister	0x0100
+#define EEReadRegister	0x0200
+#define EEEraseRegister	0x0300
+#define ELSEL			0x0400
+
+#endif	/* #ifndef CS8900_H */
diff -urN linux-2.6.27new/drivers/net/arm/Kconfig linux-2.6.27/drivers/net/arm/Kconfig
--- linux-2.6.27new/drivers/net/arm/Kconfig	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/arm/Kconfig	2009-07-23 17:08:11.000000000 +0800
@@ -55,3 +55,17 @@
 	help
 	  Say Y here if you want to use built-in Ethernet ports
 	  on IXP4xx processor.
+
+config CS8900
+	tristate "CS8900A support"
+	depends on NET_PCI && (ISA || MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X || MACH_AKAE2440)
+	---help---
+	  Support for CS8900A chipset based Ethernet cards. If you have a
+	  network (Ethernet) card of this type, say Y and read the
+	  Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto> as well as
+	  <file:Documentation/networking/cs89x0.txt>.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called cs89x0.
+
diff -urN linux-2.6.27new/drivers/net/arm/Makefile linux-2.6.27/drivers/net/arm/Makefile
--- linux-2.6.27new/drivers/net/arm/Makefile	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/arm/Makefile	2009-07-23 17:08:11.000000000 +0800
@@ -10,3 +10,4 @@
 obj-$(CONFIG_ARM_AT91_ETHER)	+= at91_ether.o
 obj-$(CONFIG_EP93XX_ETH)	+= ep93xx_eth.o
 obj-$(CONFIG_IXP4XX_ETH)	+= ixp4xx_eth.o
+obj-$(CONFIG_CS8900)		+= cs8900.o
diff -urN linux-2.6.27new/drivers/net/cs89x0.c linux-2.6.27/drivers/net/cs89x0.c
--- linux-2.6.27new/drivers/net/cs89x0.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/cs89x0.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,1991 +0,0 @@
-/* cs89x0.c: A Crystal Semiconductor (Now Cirrus Logic) CS89[02]0
- *  driver for linux.
- */
-
-/*
-	Written 1996 by Russell Nelson, with reference to skeleton.c
-	written 1993-1994 by Donald Becker.
-
-	This software may be used and distributed according to the terms
-	of the GNU General Public License, incorporated herein by reference.
-
-        The author may be reached at nelson@crynwr.com, Crynwr
-        Software, 521 Pleasant Valley Rd., Potsdam, NY 13676
-
-  Changelog:
-
-  Mike Cruse        : mcruse@cti-ltd.com
-                    : Changes for Linux 2.0 compatibility.
-                    : Added dev_id parameter in net_interrupt(),
-                    : request_irq() and free_irq(). Just NULL for now.
-
-  Mike Cruse        : Added MOD_INC_USE_COUNT and MOD_DEC_USE_COUNT macros
-                    : in net_open() and net_close() so kerneld would know
-                    : that the module is in use and wouldn't eject the
-                    : driver prematurely.
-
-  Mike Cruse        : Rewrote init_module() and cleanup_module using 8390.c
-                    : as an example. Disabled autoprobing in init_module(),
-                    : not a good thing to do to other devices while Linux
-                    : is running from all accounts.
-
-  Russ Nelson       : Jul 13 1998.  Added RxOnly DMA support.
-
-  Melody Lee        : Aug 10 1999.  Changes for Linux 2.2.5 compatibility.
-                    : email: ethernet@crystal.cirrus.com
-
-  Alan Cox          : Removed 1.2 support, added 2.1 extra counters.
-
-  Andrew Morton     : andrewm@uow.edu.au
-                    : Kernel 2.3.48
-                    : Handle kmalloc() failures
-                    : Other resource allocation fixes
-                    : Add SMP locks
-                    : Integrate Russ Nelson's ALLOW_DMA functionality back in.
-                    : If ALLOW_DMA is true, make DMA runtime selectable
-                    : Folded in changes from Cirrus (Melody Lee
-                    : <klee@crystal.cirrus.com>)
-                    : Don't call netif_wake_queue() in net_send_packet()
-                    : Fixed an out-of-mem bug in dma_rx()
-                    : Updated Documentation/networking/cs89x0.txt
-
-  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre1
-                    : Use skb_reserve to longword align IP header (two places)
-                    : Remove a delay loop from dma_rx()
-                    : Replace '100' with HZ
-                    : Clean up a couple of skb API abuses
-                    : Added 'cs89x0_dma=N' kernel boot option
-                    : Correctly initialise lp->lock in non-module compile
-
-  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.3.99-pre4-1
-                    : MOD_INC/DEC race fix (see
-                    : http://www.uwsg.indiana.edu/hypermail/linux/kernel/0003.3/1532.html)
-
-  Andrew Morton     : andrewm@uow.edu.au / Kernel 2.4.0-test7-pre2
-                    : Enhanced EEPROM support to cover more devices,
-                    :   abstracted IRQ mapping to support CONFIG_ARCH_CLPS7500 arch
-                    :   (Jason Gunthorpe <jgg@ualberta.ca>)
-
-  Andrew Morton     : Kernel 2.4.0-test11-pre4
-                    : Use dev->name in request_*() (Andrey Panin)
-                    : Fix an error-path memleak in init_module()
-                    : Preserve return value from request_irq()
-                    : Fix type of `media' module parm (Keith Owens)
-                    : Use SET_MODULE_OWNER()
-                    : Tidied up strange request_irq() abuse in net_open().
-
-  Andrew Morton     : Kernel 2.4.3-pre1
-                    : Request correct number of pages for DMA (Hugh Dickens)
-                    : Select PP_ChipID _after_ unregister_netdev in cleanup_module()
-                    :  because unregister_netdev() calls get_stats.
-                    : Make `version[]' __initdata
-                    : Uninlined the read/write reg/word functions.
-
-  Oskar Schirmer    : oskar@scara.com
-                    : HiCO.SH4 (superh) support added (irq#1, cs89x0_media=)
-
-  Deepak Saxena     : dsaxena@plexity.net
-                    : Intel IXDP2x01 (XScale ixp2x00 NPU) platform support
-
-  Dmitry Pervushin  : dpervushin@ru.mvista.com
-                    : PNX010X platform support
-
-  Deepak Saxena     : dsaxena@plexity.net
-                    : Intel IXDP2351 platform support
-
-  Dmitry Pervushin  : dpervushin@ru.mvista.com
-                    : PNX010X platform support
-
-*/
-
-/* Always include 'config.h' first in case the user wants to turn on
-   or override something. */
-#include <linux/module.h>
-
-/*
- * Set this to zero to disable DMA code
- *
- * Note that even if DMA is turned off we still support the 'dma' and  'use_dma'
- * module options so we don't break any startup scripts.
- */
-#ifndef CONFIG_ISA_DMA_API
-#define ALLOW_DMA	0
-#else
-#define ALLOW_DMA	1
-#endif
-
-/*
- * Set this to zero to remove all the debug statements via
- * dead code elimination
- */
-#define DEBUGGING	1
-
-/*
-  Sources:
-
-	Crynwr packet driver epktisa.
-
-	Crystal Semiconductor data sheets.
-
-*/
-
-#include <linux/errno.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/fcntl.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/in.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/bitops.h>
-#include <linux/delay.h>
-
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#if ALLOW_DMA
-#include <asm/dma.h>
-#endif
-
-#include "cs89x0.h"
-
-static char version[] __initdata =
-"cs89x0.c: v2.4.3-pre1 Russell Nelson <nelson@crynwr.com>, Andrew Morton <andrewm@uow.edu.au>\n";
-
-#define DRV_NAME "cs89x0"
-
-/* First, a few definitions that the brave might change.
-   A zero-terminated list of I/O addresses to be probed. Some special flags..
-      Addr & 1 = Read back the address port, look for signature and reset
-                 the page window before probing
-      Addr & 3 = Reset the page window and probe
-   The CLPS eval board has the Cirrus chip at 0x80090300, in ARM IO space,
-   but it is possible that a Cirrus board could be plugged into the ISA
-   slots. */
-/* The cs8900 has 4 IRQ pins, software selectable. cs8900_irq_map maps
-   them to system IRQ numbers. This mapping is card specific and is set to
-   the configuration of the Cirrus Eval board for this chip. */
-#ifdef CONFIG_ARCH_CLPS7500
-static unsigned int netcard_portlist[] __used __initdata =
-   { 0x80090303, 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
-static unsigned int cs8900_irq_map[] = {12,0,0,0};
-#elif defined(CONFIG_SH_HICOSH4)
-static unsigned int netcard_portlist[] __used __initdata =
-   { 0x0300, 0};
-static unsigned int cs8900_irq_map[] = {1,0,0,0};
-#elif defined(CONFIG_MACH_IXDP2351)
-static unsigned int netcard_portlist[] __used __initdata = {IXDP2351_VIRT_CS8900_BASE, 0};
-static unsigned int cs8900_irq_map[] = {IRQ_IXDP2351_CS8900, 0, 0, 0};
-#include <asm/irq.h>
-#elif defined(CONFIG_ARCH_IXDP2X01)
-#include <asm/irq.h>
-static unsigned int netcard_portlist[] __used __initdata = {IXDP2X01_CS8900_VIRT_BASE, 0};
-static unsigned int cs8900_irq_map[] = {IRQ_IXDP2X01_CS8900, 0, 0, 0};
-#elif defined(CONFIG_ARCH_PNX010X)
-#include <asm/irq.h>
-#include <mach/gpio.h>
-#define CIRRUS_DEFAULT_BASE	IO_ADDRESS(EXT_STATIC2_s0_BASE + 0x200000)	/* = Physical address 0x48200000 */
-#define CIRRUS_DEFAULT_IRQ	VH_INTC_INT_NUM_CASCADED_INTERRUPT_1 /* Event inputs bank 1 - ID 35/bit 3 */
-static unsigned int netcard_portlist[] __used __initdata = {CIRRUS_DEFAULT_BASE, 0};
-static unsigned int cs8900_irq_map[] = {CIRRUS_DEFAULT_IRQ, 0, 0, 0};
-#else
-static unsigned int netcard_portlist[] __used __initdata =
-   { 0x300, 0x320, 0x340, 0x360, 0x200, 0x220, 0x240, 0x260, 0x280, 0x2a0, 0x2c0, 0x2e0, 0};
-static unsigned int cs8900_irq_map[] = {10,11,12,5};
-#endif
-
-#if DEBUGGING
-static unsigned int net_debug = DEBUGGING;
-#else
-#define net_debug 0	/* gcc will remove all the debug code for us */
-#endif
-
-/* The number of low I/O ports used by the ethercard. */
-#define NETCARD_IO_EXTENT	16
-
-/* we allow the user to override various values normally set in the EEPROM */
-#define FORCE_RJ45	0x0001    /* pick one of these three */
-#define FORCE_AUI	0x0002
-#define FORCE_BNC	0x0004
-
-#define FORCE_AUTO	0x0010    /* pick one of these three */
-#define FORCE_HALF	0x0020
-#define FORCE_FULL	0x0030
-
-/* Information that need to be kept for each board. */
-struct net_local {
-	struct net_device_stats stats;
-	int chip_type;		/* one of: CS8900, CS8920, CS8920M */
-	char chip_revision;	/* revision letter of the chip ('A'...) */
-	int send_cmd;		/* the proper send command: TX_NOW, TX_AFTER_381, or TX_AFTER_ALL */
-	int auto_neg_cnf;	/* auto-negotiation word from EEPROM */
-	int adapter_cnf;	/* adapter configuration from EEPROM */
-	int isa_config;		/* ISA configuration from EEPROM */
-	int irq_map;		/* IRQ map from EEPROM */
-	int rx_mode;		/* what mode are we in? 0, RX_MULTCAST_ACCEPT, or RX_ALL_ACCEPT */
-	int curr_rx_cfg;	/* a copy of PP_RxCFG */
-	int linectl;		/* either 0 or LOW_RX_SQUELCH, depending on configuration. */
-	int send_underrun;	/* keep track of how many underruns in a row we get */
-	int force;		/* force various values; see FORCE* above. */
-	spinlock_t lock;
-#if ALLOW_DMA
-	int use_dma;		/* Flag: we're using dma */
-	int dma;		/* DMA channel */
-	int dmasize;		/* 16 or 64 */
-	unsigned char *dma_buff;	/* points to the beginning of the buffer */
-	unsigned char *end_dma_buff;	/* points to the end of the buffer */
-	unsigned char *rx_dma_ptr;	/* points to the next packet  */
-#endif
-};
-
-/* Index to functions, as function prototypes. */
-
-static int cs89x0_probe1(struct net_device *dev, int ioaddr, int modular);
-static int net_open(struct net_device *dev);
-static int net_send_packet(struct sk_buff *skb, struct net_device *dev);
-static irqreturn_t net_interrupt(int irq, void *dev_id);
-static void set_multicast_list(struct net_device *dev);
-static void net_timeout(struct net_device *dev);
-static void net_rx(struct net_device *dev);
-static int net_close(struct net_device *dev);
-static struct net_device_stats *net_get_stats(struct net_device *dev);
-static void reset_chip(struct net_device *dev);
-static int get_eeprom_data(struct net_device *dev, int off, int len, int *buffer);
-static int get_eeprom_cksum(int off, int len, int *buffer);
-static int set_mac_address(struct net_device *dev, void *addr);
-static void count_rx_errors(int status, struct net_local *lp);
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void net_poll_controller(struct net_device *dev);
-#endif
-#if ALLOW_DMA
-static void get_dma_channel(struct net_device *dev);
-static void release_dma_buff(struct net_local *lp);
-#endif
-
-/* Example routines you must write ;->. */
-#define tx_done(dev) 1
-
-/*
- * Permit 'cs89x0_dma=N' in the kernel boot environment
- */
-#if !defined(MODULE) && (ALLOW_DMA != 0)
-static int g_cs89x0_dma;
-
-static int __init dma_fn(char *str)
-{
-	g_cs89x0_dma = simple_strtol(str,NULL,0);
-	return 1;
-}
-
-__setup("cs89x0_dma=", dma_fn);
-#endif	/* !defined(MODULE) && (ALLOW_DMA != 0) */
-
-#ifndef MODULE
-static int g_cs89x0_media__force;
-
-static int __init media_fn(char *str)
-{
-	if (!strcmp(str, "rj45")) g_cs89x0_media__force = FORCE_RJ45;
-	else if (!strcmp(str, "aui")) g_cs89x0_media__force = FORCE_AUI;
-	else if (!strcmp(str, "bnc")) g_cs89x0_media__force = FORCE_BNC;
-	return 1;
-}
-
-__setup("cs89x0_media=", media_fn);
-
-
-/* Check for a network adaptor of this type, and return '0' iff one exists.
-   If dev->base_addr == 0, probe all likely locations.
-   If dev->base_addr == 1, always return failure.
-   If dev->base_addr == 2, allocate space for the device and return success
-   (detachable devices only).
-   Return 0 on success.
-   */
-
-struct net_device * __init cs89x0_probe(int unit)
-{
-	struct net_device *dev = alloc_etherdev(sizeof(struct net_local));
-	unsigned *port;
-	int err = 0;
-	int irq;
-	int io;
-
-	if (!dev)
-		return ERR_PTR(-ENODEV);
-
-	sprintf(dev->name, "eth%d", unit);
-	netdev_boot_setup_check(dev);
-	io = dev->base_addr;
-	irq = dev->irq;
-
-	if (net_debug)
-		printk("cs89x0:cs89x0_probe(0x%x)\n", io);
-
-	if (io > 0x1ff)	{	/* Check a single specified location. */
-		err = cs89x0_probe1(dev, io, 0);
-	} else if (io != 0) {	/* Don't probe at all. */
-		err = -ENXIO;
-	} else {
-		for (port = netcard_portlist; *port; port++) {
-			if (cs89x0_probe1(dev, *port, 0) == 0)
-				break;
-			dev->irq = irq;
-		}
-		if (!*port)
-			err = -ENODEV;
-	}
-	if (err)
-		goto out;
-	return dev;
-out:
-	free_netdev(dev);
-	printk(KERN_WARNING "cs89x0: no cs8900 or cs8920 detected.  Be sure to disable PnP with SETUP\n");
-	return ERR_PTR(err);
-}
-#endif
-
-#if defined(CONFIG_MACH_IXDP2351)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	return __raw_readw(base_addr + (portno << 1));
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	__raw_writew(value, base_addr + (portno << 1));
-}
-#elif defined(CONFIG_ARCH_IXDP2X01)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	return __raw_readl(base_addr + (portno << 1));
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	__raw_writel(value, base_addr + (portno << 1));
-}
-#elif defined(CONFIG_ARCH_PNX010X)
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	return inw(base_addr + (portno << 1));
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	outw(value, base_addr + (portno << 1));
-}
-#else
-static u16
-readword(unsigned long base_addr, int portno)
-{
-	return inw(base_addr + portno);
-}
-
-static void
-writeword(unsigned long base_addr, int portno, u16 value)
-{
-	outw(value, base_addr + portno);
-}
-#endif
-
-static void
-readwords(unsigned long base_addr, int portno, void *buf, int length)
-{
-	u8 *buf8 = (u8 *)buf;
-
-	do {
-		u16 tmp16;
-
-		tmp16 = readword(base_addr, portno);
-		*buf8++ = (u8)tmp16;
-		*buf8++ = (u8)(tmp16 >> 8);
-	} while (--length);
-}
-
-static void
-writewords(unsigned long base_addr, int portno, void *buf, int length)
-{
-	u8 *buf8 = (u8 *)buf;
-
-	do {
-		u16 tmp16;
-
-		tmp16 = *buf8++;
-		tmp16 |= (*buf8++) << 8;
-		writeword(base_addr, portno, tmp16);
-	} while (--length);
-}
-
-static u16
-readreg(struct net_device *dev, u16 regno)
-{
-	writeword(dev->base_addr, ADD_PORT, regno);
-	return readword(dev->base_addr, DATA_PORT);
-}
-
-static void
-writereg(struct net_device *dev, u16 regno, u16 value)
-{
-	writeword(dev->base_addr, ADD_PORT, regno);
-	writeword(dev->base_addr, DATA_PORT, value);
-}
-
-static int __init
-wait_eeprom_ready(struct net_device *dev)
-{
-	int timeout = jiffies;
-	/* check to see if the EEPROM is ready, a timeout is used -
-	   just in case EEPROM is ready when SI_BUSY in the
-	   PP_SelfST is clear */
-	while(readreg(dev, PP_SelfST) & SI_BUSY)
-		if (jiffies - timeout >= 40)
-			return -1;
-	return 0;
-}
-
-static int __init
-get_eeprom_data(struct net_device *dev, int off, int len, int *buffer)
-{
-	int i;
-
-	if (net_debug > 3) printk("EEPROM data from %x for %x:\n",off,len);
-	for (i = 0; i < len; i++) {
-		if (wait_eeprom_ready(dev) < 0) return -1;
-		/* Now send the EEPROM read command and EEPROM location to read */
-		writereg(dev, PP_EECMD, (off + i) | EEPROM_READ_CMD);
-		if (wait_eeprom_ready(dev) < 0) return -1;
-		buffer[i] = readreg(dev, PP_EEData);
-		if (net_debug > 3) printk("%04x ", buffer[i]);
-	}
-	if (net_debug > 3) printk("\n");
-        return 0;
-}
-
-static int  __init
-get_eeprom_cksum(int off, int len, int *buffer)
-{
-	int i, cksum;
-
-	cksum = 0;
-	for (i = 0; i < len; i++)
-		cksum += buffer[i];
-	cksum &= 0xffff;
-	if (cksum == 0)
-		return 0;
-	return -1;
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/*
- * Polling receive - used by netconsole and other diagnostic tools
- * to allow network i/o with interrupts disabled.
- */
-static void net_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-	net_interrupt(dev->irq, dev);
-	enable_irq(dev->irq);
-}
-#endif
-
-/* This is the real probe routine.  Linux has a history of friendly device
-   probes on the ISA bus.  A good device probes avoids doing writes, and
-   verifies that the correct device exists and functions.
-   Return 0 on success.
- */
-
-static int __init
-cs89x0_probe1(struct net_device *dev, int ioaddr, int modular)
-{
-	struct net_local *lp = netdev_priv(dev);
-	static unsigned version_printed;
-	int i;
-	int tmp;
-	unsigned rev_type = 0;
-	int eeprom_buff[CHKSUM_LEN];
-	int retval;
-	DECLARE_MAC_BUF(mac);
-
-	/* Initialize the device structure. */
-	if (!modular) {
-		memset(lp, 0, sizeof(*lp));
-		spin_lock_init(&lp->lock);
-#ifndef MODULE
-#if ALLOW_DMA
-		if (g_cs89x0_dma) {
-			lp->use_dma = 1;
-			lp->dma = g_cs89x0_dma;
-			lp->dmasize = 16;	/* Could make this an option... */
-		}
-#endif
-		lp->force = g_cs89x0_media__force;
-#endif
-        }
-
-#ifdef CONFIG_ARCH_PNX010X
-	initialize_ebi();
-
-	/* Map GPIO registers for the pins connected to the CS8900a. */
-	if (map_cirrus_gpio() < 0)
-		return -ENODEV;
-
-	reset_cirrus();
-
-	/* Map event-router registers. */
-	if (map_event_router() < 0)
-		return -ENODEV;
-
-	enable_cirrus_irq();
-
-	unmap_cirrus_gpio();
-	unmap_event_router();
-
-	dev->base_addr = ioaddr;
-
-	for (i = 0 ; i < 3 ; i++)
-		readreg(dev, 0);
-#endif
-
-	/* Grab the region so we can find another board if autoIRQ fails. */
-	/* WTF is going on here? */
-	if (!request_region(ioaddr & ~3, NETCARD_IO_EXTENT, DRV_NAME)) {
-		printk(KERN_ERR "%s: request_region(0x%x, 0x%x) failed\n",
-				DRV_NAME, ioaddr, NETCARD_IO_EXTENT);
-		retval = -EBUSY;
-		goto out1;
-	}
-
-#ifdef CONFIG_SH_HICOSH4
-	/* truely reset the chip */
-	writeword(ioaddr, ADD_PORT, 0x0114);
-	writeword(ioaddr, DATA_PORT, 0x0040);
-#endif
-
-	/* if they give us an odd I/O address, then do ONE write to
-           the address port, to get it back to address zero, where we
-           expect to find the EISA signature word. An IO with a base of 0x3
-	   will skip the test for the ADD_PORT. */
-	if (ioaddr & 1) {
-		if (net_debug > 1)
-			printk(KERN_INFO "%s: odd ioaddr 0x%x\n", dev->name, ioaddr);
-	        if ((ioaddr & 2) != 2)
-	        	if ((readword(ioaddr & ~3, ADD_PORT) & ADD_MASK) != ADD_SIG) {
-				printk(KERN_ERR "%s: bad signature 0x%x\n",
-					dev->name, readword(ioaddr & ~3, ADD_PORT));
-		        	retval = -ENODEV;
-				goto out2;
-			}
-	}
-
-	ioaddr &= ~3;
-	printk(KERN_DEBUG "PP_addr at %x[%x]: 0x%x\n",
-			ioaddr, ADD_PORT, readword(ioaddr, ADD_PORT));
-	writeword(ioaddr, ADD_PORT, PP_ChipID);
-
-	tmp = readword(ioaddr, DATA_PORT);
-	if (tmp != CHIP_EISA_ID_SIG) {
-		printk(KERN_DEBUG "%s: incorrect signature at %x[%x]: 0x%x!="
-			CHIP_EISA_ID_SIG_STR "\n",
-			dev->name, ioaddr, DATA_PORT, tmp);
-  		retval = -ENODEV;
-  		goto out2;
-	}
-
-	/* Fill in the 'dev' fields. */
-	dev->base_addr = ioaddr;
-
-	/* get the chip type */
-	rev_type = readreg(dev, PRODUCT_ID_ADD);
-	lp->chip_type = rev_type &~ REVISON_BITS;
-	lp->chip_revision = ((rev_type & REVISON_BITS) >> 8) + 'A';
-
-	/* Check the chip type and revision in order to set the correct send command
-	CS8920 revision C and CS8900 revision F can use the faster send. */
-	lp->send_cmd = TX_AFTER_381;
-	if (lp->chip_type == CS8900 && lp->chip_revision >= 'F')
-		lp->send_cmd = TX_NOW;
-	if (lp->chip_type != CS8900 && lp->chip_revision >= 'C')
-		lp->send_cmd = TX_NOW;
-
-	if (net_debug  &&  version_printed++ == 0)
-		printk(version);
-
-	printk(KERN_INFO "%s: cs89%c0%s rev %c found at %#3lx ",
-	       dev->name,
-	       lp->chip_type==CS8900?'0':'2',
-	       lp->chip_type==CS8920M?"M":"",
-	       lp->chip_revision,
-	       dev->base_addr);
-
-	reset_chip(dev);
-
-        /* Here we read the current configuration of the chip. If there
-	   is no Extended EEPROM then the idea is to not disturb the chip
-	   configuration, it should have been correctly setup by automatic
-	   EEPROM read on reset. So, if the chip says it read the EEPROM
-	   the driver will always do *something* instead of complain that
-	   adapter_cnf is 0. */
-
-#ifdef CONFIG_SH_HICOSH4
-	if (1) {
-		/* For the HiCO.SH4 board, things are different: we don't
-		   have EEPROM, but there is some data in flash, so we go
-		   get it there directly (MAC). */
-		__u16 *confd;
-		short cnt;
-		if (((* (volatile __u32 *) 0xa0013ff0) & 0x00ffffff)
-			== 0x006c3000) {
-			confd = (__u16*) 0xa0013fc0;
-		} else {
-			confd = (__u16*) 0xa001ffc0;
-		}
-		cnt = (*confd++ & 0x00ff) >> 1;
-		while (--cnt > 0) {
-			__u16 j = *confd++;
-
-			switch (j & 0x0fff) {
-			case PP_IA:
-				for (i = 0; i < ETH_ALEN/2; i++) {
-					dev->dev_addr[i*2] = confd[i] & 0xFF;
-					dev->dev_addr[i*2+1] = confd[i] >> 8;
-				}
-				break;
-			}
-			j = (j >> 12) + 1;
-			confd += j;
-			cnt -= j;
-		}
-	} else
-#endif
-
-        if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) ==
-	      (EEPROM_OK|EEPROM_PRESENT)) {
-	        /* Load the MAC. */
-		for (i=0; i < ETH_ALEN/2; i++) {
-	                unsigned int Addr;
-			Addr = readreg(dev, PP_IA+i*2);
-		        dev->dev_addr[i*2] = Addr & 0xFF;
-		        dev->dev_addr[i*2+1] = Addr >> 8;
-		}
-
-	   	/* Load the Adapter Configuration.
-		   Note:  Barring any more specific information from some
-		   other source (ie EEPROM+Schematics), we would not know
-		   how to operate a 10Base2 interface on the AUI port.
-		   However, since we  do read the status of HCB1 and use
-		   settings that always result in calls to control_dc_dc(dev,0)
-		   a BNC interface should work if the enable pin
-		   (dc/dc converter) is on HCB1. It will be called AUI
-		   however. */
-
-		lp->adapter_cnf = 0;
-		i = readreg(dev, PP_LineCTL);
-		/* Preserve the setting of the HCB1 pin. */
-		if ((i & (HCB1 | HCB1_ENBL)) ==  (HCB1 | HCB1_ENBL))
-			lp->adapter_cnf |= A_CNF_DC_DC_POLARITY;
-		/* Save the sqelch bit */
-		if ((i & LOW_RX_SQUELCH) == LOW_RX_SQUELCH)
-			lp->adapter_cnf |= A_CNF_EXTND_10B_2 | A_CNF_LOW_RX_SQUELCH;
-		/* Check if the card is in 10Base-t only mode */
-		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == 0)
-			lp->adapter_cnf |=  A_CNF_10B_T | A_CNF_MEDIA_10B_T;
-		/* Check if the card is in AUI only mode */
-		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUI_ONLY)
-			lp->adapter_cnf |=  A_CNF_AUI | A_CNF_MEDIA_AUI;
-		/* Check if the card is in Auto mode. */
-		if ((i & (AUI_ONLY | AUTO_AUI_10BASET)) == AUTO_AUI_10BASET)
-			lp->adapter_cnf |=  A_CNF_AUI | A_CNF_10B_T |
-			A_CNF_MEDIA_AUI | A_CNF_MEDIA_10B_T | A_CNF_MEDIA_AUTO;
-
-		if (net_debug > 1)
-			printk(KERN_INFO "%s: PP_LineCTL=0x%x, adapter_cnf=0x%x\n",
-					dev->name, i, lp->adapter_cnf);
-
-		/* IRQ. Other chips already probe, see below. */
-		if (lp->chip_type == CS8900)
-			lp->isa_config = readreg(dev, PP_CS8900_ISAINT) & INT_NO_MASK;
-
-		printk( "[Cirrus EEPROM] ");
-	}
-
-        printk("\n");
-
-	/* First check to see if an EEPROM is attached. */
-#ifdef CONFIG_SH_HICOSH4 /* no EEPROM on HiCO, don't hazzle with it here */
-	if (1) {
-		printk(KERN_NOTICE "cs89x0: No EEPROM on HiCO.SH4\n");
-	} else
-#endif
-	if ((readreg(dev, PP_SelfST) & EEPROM_PRESENT) == 0)
-		printk(KERN_WARNING "cs89x0: No EEPROM, relying on command line....\n");
-	else if (get_eeprom_data(dev, START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {
-		printk(KERN_WARNING "\ncs89x0: EEPROM read failed, relying on command line.\n");
-        } else if (get_eeprom_cksum(START_EEPROM_DATA,CHKSUM_LEN,eeprom_buff) < 0) {
-		/* Check if the chip was able to read its own configuration starting
-		   at 0 in the EEPROM*/
-		if ((readreg(dev, PP_SelfST) & (EEPROM_OK | EEPROM_PRESENT)) !=
-		    (EEPROM_OK|EEPROM_PRESENT))
-                	printk(KERN_WARNING "cs89x0: Extended EEPROM checksum bad and no Cirrus EEPROM, relying on command line\n");
-
-        } else {
-		/* This reads an extended EEPROM that is not documented
-		   in the CS8900 datasheet. */
-
-                /* get transmission control word  but keep the autonegotiation bits */
-                if (!lp->auto_neg_cnf) lp->auto_neg_cnf = eeprom_buff[AUTO_NEG_CNF_OFFSET/2];
-                /* Store adapter configuration */
-                if (!lp->adapter_cnf) lp->adapter_cnf = eeprom_buff[ADAPTER_CNF_OFFSET/2];
-                /* Store ISA configuration */
-                lp->isa_config = eeprom_buff[ISA_CNF_OFFSET/2];
-                dev->mem_start = eeprom_buff[PACKET_PAGE_OFFSET/2] << 8;
-
-                /* eeprom_buff has 32-bit ints, so we can't just memcpy it */
-                /* store the initial memory base address */
-                for (i = 0; i < ETH_ALEN/2; i++) {
-                        dev->dev_addr[i*2] = eeprom_buff[i];
-                        dev->dev_addr[i*2+1] = eeprom_buff[i] >> 8;
-                }
-		if (net_debug > 1)
-			printk(KERN_DEBUG "%s: new adapter_cnf: 0x%x\n",
-				dev->name, lp->adapter_cnf);
-        }
-
-        /* allow them to force multiple transceivers.  If they force multiple, autosense */
-        {
-		int count = 0;
-		if (lp->force & FORCE_RJ45)	{lp->adapter_cnf |= A_CNF_10B_T; count++; }
-		if (lp->force & FORCE_AUI) 	{lp->adapter_cnf |= A_CNF_AUI; count++; }
-		if (lp->force & FORCE_BNC)	{lp->adapter_cnf |= A_CNF_10B_2; count++; }
-		if (count > 1)			{lp->adapter_cnf |= A_CNF_MEDIA_AUTO; }
-		else if (lp->force & FORCE_RJ45){lp->adapter_cnf |= A_CNF_MEDIA_10B_T; }
-		else if (lp->force & FORCE_AUI)	{lp->adapter_cnf |= A_CNF_MEDIA_AUI; }
-		else if (lp->force & FORCE_BNC)	{lp->adapter_cnf |= A_CNF_MEDIA_10B_2; }
-        }
-
-	if (net_debug > 1)
-		printk(KERN_DEBUG "%s: after force 0x%x, adapter_cnf=0x%x\n",
-			dev->name, lp->force, lp->adapter_cnf);
-
-        /* FIXME: We don't let you set dc-dc polarity or low RX squelch from the command line: add it here */
-
-        /* FIXME: We don't let you set the IMM bit from the command line: add it to lp->auto_neg_cnf here */
-
-        /* FIXME: we don't set the Ethernet address on the command line.  Use
-           ifconfig IFACE hw ether AABBCCDDEEFF */
-
-	printk(KERN_INFO "cs89x0 media %s%s%s",
-	       (lp->adapter_cnf & A_CNF_10B_T)?"RJ-45,":"",
-	       (lp->adapter_cnf & A_CNF_AUI)?"AUI,":"",
-	       (lp->adapter_cnf & A_CNF_10B_2)?"BNC,":"");
-
-	lp->irq_map = 0xffff;
-
-	/* If this is a CS8900 then no pnp soft */
-	if (lp->chip_type != CS8900 &&
-	    /* Check if the ISA IRQ has been set  */
-		(i = readreg(dev, PP_CS8920_ISAINT) & 0xff,
-		 (i != 0 && i < CS8920_NO_INTS))) {
-		if (!dev->irq)
-			dev->irq = i;
-	} else {
-		i = lp->isa_config & INT_NO_MASK;
-		if (lp->chip_type == CS8900) {
-#if defined(CONFIG_MACH_IXDP2351) || defined(CONFIG_ARCH_IXDP2X01) || defined(CONFIG_ARCH_PNX010X)
-		        i = cs8900_irq_map[0];
-#else
-			/* Translate the IRQ using the IRQ mapping table. */
-			if (i >= ARRAY_SIZE(cs8900_irq_map))
-				printk("\ncs89x0: invalid ISA interrupt number %d\n", i);
-			else
-				i = cs8900_irq_map[i];
-
-			lp->irq_map = CS8900_IRQ_MAP; /* fixed IRQ map for CS8900 */
-		} else {
-			int irq_map_buff[IRQ_MAP_LEN/2];
-
-			if (get_eeprom_data(dev, IRQ_MAP_EEPROM_DATA,
-					    IRQ_MAP_LEN/2,
-					    irq_map_buff) >= 0) {
-				if ((irq_map_buff[0] & 0xff) == PNP_IRQ_FRMT)
-					lp->irq_map = (irq_map_buff[0]>>8) | (irq_map_buff[1] << 8);
-			}
-#endif
-		}
-		if (!dev->irq)
-			dev->irq = i;
-	}
-
-	printk(" IRQ %d", dev->irq);
-
-#if ALLOW_DMA
-	if (lp->use_dma) {
-		get_dma_channel(dev);
-		printk(", DMA %d", dev->dma);
-	}
-	else
-#endif
-	{
-		printk(", programmed I/O");
-	}
-
-	/* print the ethernet address. */
-	printk(", MAC %s", print_mac(mac, dev->dev_addr));
-
-	dev->open		= net_open;
-	dev->stop		= net_close;
-	dev->tx_timeout		= net_timeout;
-	dev->watchdog_timeo	= HZ;
-	dev->hard_start_xmit 	= net_send_packet;
-	dev->get_stats		= net_get_stats;
-	dev->set_multicast_list = set_multicast_list;
-	dev->set_mac_address 	= set_mac_address;
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller	= net_poll_controller;
-#endif
-
-	printk("\n");
-	if (net_debug)
-		printk("cs89x0_probe1() successful\n");
-
-	retval = register_netdev(dev);
-	if (retval)
-		goto out3;
-	return 0;
-out3:
-	writeword(dev->base_addr, ADD_PORT, PP_ChipID);
-out2:
-	release_region(ioaddr & ~3, NETCARD_IO_EXTENT);
-out1:
-	return retval;
-}
-
-
-/*********************************
- * This page contains DMA routines
-**********************************/
-
-#if ALLOW_DMA
-
-#define dma_page_eq(ptr1, ptr2) ((long)(ptr1)>>17 == (long)(ptr2)>>17)
-
-static void
-get_dma_channel(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-
-	if (lp->dma) {
-		dev->dma = lp->dma;
-		lp->isa_config |= ISA_RxDMA;
-	} else {
-		if ((lp->isa_config & ANY_ISA_DMA) == 0)
-			return;
-		dev->dma = lp->isa_config & DMA_NO_MASK;
-		if (lp->chip_type == CS8900)
-			dev->dma += 5;
-		if (dev->dma < 5 || dev->dma > 7) {
-			lp->isa_config &= ~ANY_ISA_DMA;
-			return;
-		}
-	}
-	return;
-}
-
-static void
-write_dma(struct net_device *dev, int chip_type, int dma)
-{
-	struct net_local *lp = netdev_priv(dev);
-	if ((lp->isa_config & ANY_ISA_DMA) == 0)
-		return;
-	if (chip_type == CS8900) {
-		writereg(dev, PP_CS8900_ISADMA, dma-5);
-	} else {
-		writereg(dev, PP_CS8920_ISADMA, dma);
-	}
-}
-
-static void
-set_dma_cfg(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-
-	if (lp->use_dma) {
-		if ((lp->isa_config & ANY_ISA_DMA) == 0) {
-			if (net_debug > 3)
-				printk("set_dma_cfg(): no DMA\n");
-			return;
-		}
-		if (lp->isa_config & ISA_RxDMA) {
-			lp->curr_rx_cfg |= RX_DMA_ONLY;
-			if (net_debug > 3)
-				printk("set_dma_cfg(): RX_DMA_ONLY\n");
-		} else {
-			lp->curr_rx_cfg |= AUTO_RX_DMA;	/* not that we support it... */
-			if (net_debug > 3)
-				printk("set_dma_cfg(): AUTO_RX_DMA\n");
-		}
-	}
-}
-
-static int
-dma_bufcfg(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	if (lp->use_dma)
-		return (lp->isa_config & ANY_ISA_DMA)? RX_DMA_ENBL : 0;
-	else
-		return 0;
-}
-
-static int
-dma_busctl(struct net_device *dev)
-{
-	int retval = 0;
-	struct net_local *lp = netdev_priv(dev);
-	if (lp->use_dma) {
-		if (lp->isa_config & ANY_ISA_DMA)
-			retval |= RESET_RX_DMA; /* Reset the DMA pointer */
-		if (lp->isa_config & DMA_BURST)
-			retval |= DMA_BURST_MODE; /* Does ISA config specify DMA burst ? */
-		if (lp->dmasize == 64)
-			retval |= RX_DMA_SIZE_64K; /* did they ask for 64K? */
-		retval |= MEMORY_ON;	/* we need memory enabled to use DMA. */
-	}
-	return retval;
-}
-
-static void
-dma_rx(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	struct sk_buff *skb;
-	int status, length;
-	unsigned char *bp = lp->rx_dma_ptr;
-
-	status = bp[0] + (bp[1]<<8);
-	length = bp[2] + (bp[3]<<8);
-	bp += 4;
-	if (net_debug > 5) {
-		printk(	"%s: receiving DMA packet at %lx, status %x, length %x\n",
-			dev->name, (unsigned long)bp, status, length);
-	}
-	if ((status & RX_OK) == 0) {
-		count_rx_errors(status, lp);
-		goto skip_this_frame;
-	}
-
-	/* Malloc up new buffer. */
-	skb = dev_alloc_skb(length + 2);
-	if (skb == NULL) {
-		if (net_debug)	/* I don't think we want to do this to a stressed system */
-			printk("%s: Memory squeeze, dropping packet.\n", dev->name);
-		lp->stats.rx_dropped++;
-
-		/* AKPM: advance bp to the next frame */
-skip_this_frame:
-		bp += (length + 3) & ~3;
-		if (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;
-		lp->rx_dma_ptr = bp;
-		return;
-	}
-	skb_reserve(skb, 2);	/* longword align L3 header */
-
-	if (bp + length > lp->end_dma_buff) {
-		int semi_cnt = lp->end_dma_buff - bp;
-		memcpy(skb_put(skb,semi_cnt), bp, semi_cnt);
-		memcpy(skb_put(skb,length - semi_cnt), lp->dma_buff,
-		       length - semi_cnt);
-	} else {
-		memcpy(skb_put(skb,length), bp, length);
-	}
-	bp += (length + 3) & ~3;
-	if (bp >= lp->end_dma_buff) bp -= lp->dmasize*1024;
-	lp->rx_dma_ptr = bp;
-
-	if (net_debug > 3) {
-		printk(	"%s: received %d byte DMA packet of type %x\n",
-			dev->name, length,
-			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
-	}
-        skb->protocol=eth_type_trans(skb,dev);
-	netif_rx(skb);
-	dev->last_rx = jiffies;
-	lp->stats.rx_packets++;
-	lp->stats.rx_bytes += length;
-}
-
-#endif	/* ALLOW_DMA */
-
-void  __init reset_chip(struct net_device *dev)
-{
-#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01)
-	struct net_local *lp = netdev_priv(dev);
-	int ioaddr = dev->base_addr;
-#endif
-	int reset_start_time;
-
-	writereg(dev, PP_SelfCTL, readreg(dev, PP_SelfCTL) | POWER_ON_RESET);
-
-	/* wait 30 ms */
-	msleep(30);
-
-#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01)
-	if (lp->chip_type != CS8900) {
-		/* Hardware problem requires PNP registers to be reconfigured after a reset */
-		writeword(ioaddr, ADD_PORT, PP_CS8920_ISAINT);
-		outb(dev->irq, ioaddr + DATA_PORT);
-		outb(0,      ioaddr + DATA_PORT + 1);
-
-		writeword(ioaddr, ADD_PORT, PP_CS8920_ISAMemB);
-		outb((dev->mem_start >> 16) & 0xff, ioaddr + DATA_PORT);
-		outb((dev->mem_start >> 8) & 0xff,   ioaddr + DATA_PORT + 1);
-	}
-#endif	/* IXDP2x01 */
-
-	/* Wait until the chip is reset */
-	reset_start_time = jiffies;
-	while( (readreg(dev, PP_SelfST) & INIT_DONE) == 0 && jiffies - reset_start_time < 2)
-		;
-}
-
-
-static void
-control_dc_dc(struct net_device *dev, int on_not_off)
-{
-	struct net_local *lp = netdev_priv(dev);
-	unsigned int selfcontrol;
-	int timenow = jiffies;
-	/* control the DC to DC convertor in the SelfControl register.
-	   Note: This is hooked up to a general purpose pin, might not
-	   always be a DC to DC convertor. */
-
-	selfcontrol = HCB1_ENBL; /* Enable the HCB1 bit as an output */
-	if (((lp->adapter_cnf & A_CNF_DC_DC_POLARITY) != 0) ^ on_not_off)
-		selfcontrol |= HCB1;
-	else
-		selfcontrol &= ~HCB1;
-	writereg(dev, PP_SelfCTL, selfcontrol);
-
-	/* Wait for the DC/DC converter to power up - 500ms */
-	while (jiffies - timenow < HZ)
-		;
-}
-
-#define DETECTED_NONE  0
-#define DETECTED_RJ45H 1
-#define DETECTED_RJ45F 2
-#define DETECTED_AUI   3
-#define DETECTED_BNC   4
-
-static int
-detect_tp(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	int timenow = jiffies;
-	int fdx;
-
-	if (net_debug > 1) printk("%s: Attempting TP\n", dev->name);
-
-        /* If connected to another full duplex capable 10-Base-T card the link pulses
-           seem to be lost when the auto detect bit in the LineCTL is set.
-           To overcome this the auto detect bit will be cleared whilst testing the
-           10-Base-T interface.  This would not be necessary for the sparrow chip but
-           is simpler to do it anyway. */
-	writereg(dev, PP_LineCTL, lp->linectl &~ AUI_ONLY);
-	control_dc_dc(dev, 0);
-
-        /* Delay for the hardware to work out if the TP cable is present - 150ms */
-	for (timenow = jiffies; jiffies - timenow < 15; )
-                ;
-	if ((readreg(dev, PP_LineST) & LINK_OK) == 0)
-		return DETECTED_NONE;
-
-	if (lp->chip_type == CS8900) {
-                switch (lp->force & 0xf0) {
-#if 0
-                case FORCE_AUTO:
-			printk("%s: cs8900 doesn't autonegotiate\n",dev->name);
-                        return DETECTED_NONE;
-#endif
-		/* CS8900 doesn't support AUTO, change to HALF*/
-                case FORCE_AUTO:
-			lp->force &= ~FORCE_AUTO;
-                        lp->force |= FORCE_HALF;
-			break;
-		case FORCE_HALF:
-			break;
-                case FORCE_FULL:
-			writereg(dev, PP_TestCTL, readreg(dev, PP_TestCTL) | FDX_8900);
-			break;
-                }
-		fdx = readreg(dev, PP_TestCTL) & FDX_8900;
-	} else {
-		switch (lp->force & 0xf0) {
-		case FORCE_AUTO:
-			lp->auto_neg_cnf = AUTO_NEG_ENABLE;
-			break;
-		case FORCE_HALF:
-			lp->auto_neg_cnf = 0;
-			break;
-		case FORCE_FULL:
-			lp->auto_neg_cnf = RE_NEG_NOW | ALLOW_FDX;
-			break;
-                }
-
-		writereg(dev, PP_AutoNegCTL, lp->auto_neg_cnf & AUTO_NEG_MASK);
-
-		if ((lp->auto_neg_cnf & AUTO_NEG_BITS) == AUTO_NEG_ENABLE) {
-			printk(KERN_INFO "%s: negotiating duplex...\n",dev->name);
-			while (readreg(dev, PP_AutoNegST) & AUTO_NEG_BUSY) {
-				if (jiffies - timenow > 4000) {
-					printk(KERN_ERR "**** Full / half duplex auto-negotiation timed out ****\n");
-					break;
-				}
-			}
-		}
-		fdx = readreg(dev, PP_AutoNegST) & FDX_ACTIVE;
-	}
-	if (fdx)
-		return DETECTED_RJ45F;
-	else
-		return DETECTED_RJ45H;
-}
-
-/* send a test packet - return true if carrier bits are ok */
-static int
-send_test_pkt(struct net_device *dev)
-{
-	char test_packet[] = { 0,0,0,0,0,0, 0,0,0,0,0,0,
-				 0, 46, /* A 46 in network order */
-				 0, 0, /* DSAP=0 & SSAP=0 fields */
-				 0xf3, 0 /* Control (Test Req + P bit set) */ };
-	long timenow = jiffies;
-
-	writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_TX_ON);
-
-	memcpy(test_packet,          dev->dev_addr, ETH_ALEN);
-	memcpy(test_packet+ETH_ALEN, dev->dev_addr, ETH_ALEN);
-
-        writeword(dev->base_addr, TX_CMD_PORT, TX_AFTER_ALL);
-        writeword(dev->base_addr, TX_LEN_PORT, ETH_ZLEN);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	while (jiffies - timenow < 5)
-		if (readreg(dev, PP_BusST) & READY_FOR_TX_NOW)
-			break;
-	if (jiffies - timenow >= 5)
-		return 0;	/* this shouldn't happen */
-
-	/* Write the contents of the packet */
-	writewords(dev->base_addr, TX_FRAME_PORT,test_packet,(ETH_ZLEN+1) >>1);
-
-	if (net_debug > 1) printk("Sending test packet ");
-	/* wait a couple of jiffies for packet to be received */
-	for (timenow = jiffies; jiffies - timenow < 3; )
-                ;
-        if ((readreg(dev, PP_TxEvent) & TX_SEND_OK_BITS) == TX_OK) {
-                if (net_debug > 1) printk("succeeded\n");
-                return 1;
-        }
-	if (net_debug > 1) printk("failed\n");
-	return 0;
-}
-
-
-static int
-detect_aui(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-
-	if (net_debug > 1) printk("%s: Attempting AUI\n", dev->name);
-	control_dc_dc(dev, 0);
-
-	writereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(dev))
-		return DETECTED_AUI;
-	else
-		return DETECTED_NONE;
-}
-
-static int
-detect_bnc(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-
-	if (net_debug > 1) printk("%s: Attempting BNC\n", dev->name);
-	control_dc_dc(dev, 1);
-
-	writereg(dev, PP_LineCTL, (lp->linectl &~ AUTO_AUI_10BASET) | AUI_ONLY);
-
-	if (send_test_pkt(dev))
-		return DETECTED_BNC;
-	else
-		return DETECTED_NONE;
-}
-
-
-static void
-write_irq(struct net_device *dev, int chip_type, int irq)
-{
-	int i;
-
-	if (chip_type == CS8900) {
-		/* Search the mapping table for the corresponding IRQ pin. */
-		for (i = 0; i != ARRAY_SIZE(cs8900_irq_map); i++)
-			if (cs8900_irq_map[i] == irq)
-				break;
-		/* Not found */
-		if (i == ARRAY_SIZE(cs8900_irq_map))
-			i = 3;
-		writereg(dev, PP_CS8900_ISAINT, i);
-	} else {
-		writereg(dev, PP_CS8920_ISAINT, irq);
-	}
-}
-
-/* Open/initialize the board.  This is called (in the current kernel)
-   sometime after booting when the 'ifconfig' program is run.
-
-   This routine should set everything up anew at each open, even
-   registers that "should" only need to be set once at boot, so that
-   there is non-reboot way to recover if something goes wrong.
-   */
-
-/* AKPM: do we need to do any locking here? */
-
-static int
-net_open(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	int result = 0;
-	int i;
-	int ret;
-
-#if !defined(CONFIG_SH_HICOSH4) && !defined(CONFIG_ARCH_PNX010X) /* uses irq#1, so this won't work */
-	if (dev->irq < 2) {
-		/* Allow interrupts to be generated by the chip */
-/* Cirrus' release had this: */
-#if 0
-		writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
-#endif
-/* And 2.3.47 had this: */
-		writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);
-
-		for (i = 2; i < CS8920_NO_INTS; i++) {
-			if ((1 << i) & lp->irq_map) {
-				if (request_irq(i, net_interrupt, 0, dev->name, dev) == 0) {
-					dev->irq = i;
-					write_irq(dev, lp->chip_type, i);
-					/* writereg(dev, PP_BufCFG, GENERATE_SW_INTERRUPT); */
-					break;
-				}
-			}
-		}
-
-		if (i >= CS8920_NO_INTS) {
-			writereg(dev, PP_BusCTL, 0);	/* disable interrupts. */
-			printk(KERN_ERR "cs89x0: can't get an interrupt\n");
-			ret = -EAGAIN;
-			goto bad_out;
-		}
-	}
-	else
-#endif
-	{
-#if !defined(CONFIG_MACH_IXDP2351) && !defined(CONFIG_ARCH_IXDP2X01) && !defined(CONFIG_ARCH_PNX010X)
-		if (((1 << dev->irq) & lp->irq_map) == 0) {
-			printk(KERN_ERR "%s: IRQ %d is not in our map of allowable IRQs, which is %x\n",
-                               dev->name, dev->irq, lp->irq_map);
-			ret = -EAGAIN;
-			goto bad_out;
-		}
-#endif
-/* FIXME: Cirrus' release had this: */
-		writereg(dev, PP_BusCTL, readreg(dev, PP_BusCTL)|ENABLE_IRQ );
-/* And 2.3.47 had this: */
-#if 0
-		writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);
-#endif
-		write_irq(dev, lp->chip_type, dev->irq);
-		ret = request_irq(dev->irq, &net_interrupt, 0, dev->name, dev);
-		if (ret) {
-			if (net_debug)
-				printk(KERN_DEBUG "cs89x0: request_irq(%d) failed\n", dev->irq);
-			goto bad_out;
-		}
-	}
-
-#if ALLOW_DMA
-	if (lp->use_dma) {
-		if (lp->isa_config & ANY_ISA_DMA) {
-			unsigned long flags;
-			lp->dma_buff = (unsigned char *)__get_dma_pages(GFP_KERNEL,
-							get_order(lp->dmasize * 1024));
-
-			if (!lp->dma_buff) {
-				printk(KERN_ERR "%s: cannot get %dK memory for DMA\n", dev->name, lp->dmasize);
-				goto release_irq;
-			}
-			if (net_debug > 1) {
-				printk(	"%s: dma %lx %lx\n",
-					dev->name,
-					(unsigned long)lp->dma_buff,
-					(unsigned long)isa_virt_to_bus(lp->dma_buff));
-			}
-			if ((unsigned long) lp->dma_buff >= MAX_DMA_ADDRESS ||
-			    !dma_page_eq(lp->dma_buff, lp->dma_buff+lp->dmasize*1024-1)) {
-				printk(KERN_ERR "%s: not usable as DMA buffer\n", dev->name);
-				goto release_irq;
-			}
-			memset(lp->dma_buff, 0, lp->dmasize * 1024);	/* Why? */
-			if (request_dma(dev->dma, dev->name)) {
-				printk(KERN_ERR "%s: cannot get dma channel %d\n", dev->name, dev->dma);
-				goto release_irq;
-			}
-			write_dma(dev, lp->chip_type, dev->dma);
-			lp->rx_dma_ptr = lp->dma_buff;
-			lp->end_dma_buff = lp->dma_buff + lp->dmasize*1024;
-			spin_lock_irqsave(&lp->lock, flags);
-			disable_dma(dev->dma);
-			clear_dma_ff(dev->dma);
-			set_dma_mode(dev->dma, 0x14); /* auto_init as well */
-			set_dma_addr(dev->dma, isa_virt_to_bus(lp->dma_buff));
-			set_dma_count(dev->dma, lp->dmasize*1024);
-			enable_dma(dev->dma);
-			spin_unlock_irqrestore(&lp->lock, flags);
-		}
-	}
-#endif	/* ALLOW_DMA */
-
-	/* set the Ethernet address */
-	for (i=0; i < ETH_ALEN/2; i++)
-		writereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));
-
-	/* while we're testing the interface, leave interrupts disabled */
-	writereg(dev, PP_BusCTL, MEMORY_ON);
-
-	/* Set the LineCTL quintuplet based on adapter configuration read from EEPROM */
-	if ((lp->adapter_cnf & A_CNF_EXTND_10B_2) && (lp->adapter_cnf & A_CNF_LOW_RX_SQUELCH))
-                lp->linectl = LOW_RX_SQUELCH;
-	else
-                lp->linectl = 0;
-
-        /* check to make sure that they have the "right" hardware available */
-	switch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {
-	case A_CNF_MEDIA_10B_T: result = lp->adapter_cnf & A_CNF_10B_T; break;
-	case A_CNF_MEDIA_AUI:   result = lp->adapter_cnf & A_CNF_AUI; break;
-	case A_CNF_MEDIA_10B_2: result = lp->adapter_cnf & A_CNF_10B_2; break;
-        default: result = lp->adapter_cnf & (A_CNF_10B_T | A_CNF_AUI | A_CNF_10B_2);
-        }
-#ifdef CONFIG_ARCH_PNX010X
-	result = A_CNF_10B_T;
-#endif
-        if (!result) {
-                printk(KERN_ERR "%s: EEPROM is configured for unavailable media\n", dev->name);
-release_dma:
-#if ALLOW_DMA
-		free_dma(dev->dma);
-#endif
-release_irq:
-#if ALLOW_DMA
-		release_dma_buff(lp);
-#endif
-                writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) & ~(SERIAL_TX_ON | SERIAL_RX_ON));
-                free_irq(dev->irq, dev);
-		ret = -EAGAIN;
-		goto bad_out;
-	}
-
-        /* set the hardware to the configured choice */
-	switch(lp->adapter_cnf & A_CNF_MEDIA_TYPE) {
-	case A_CNF_MEDIA_10B_T:
-                result = detect_tp(dev);
-                if (result==DETECTED_NONE) {
-                        printk(KERN_WARNING "%s: 10Base-T (RJ-45) has no cable\n", dev->name);
-                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
-                                result = DETECTED_RJ45H; /* Yes! I don't care if I see a link pulse */
-                }
-		break;
-	case A_CNF_MEDIA_AUI:
-                result = detect_aui(dev);
-                if (result==DETECTED_NONE) {
-                        printk(KERN_WARNING "%s: 10Base-5 (AUI) has no cable\n", dev->name);
-                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
-                                result = DETECTED_AUI; /* Yes! I don't care if I see a carrrier */
-                }
-		break;
-	case A_CNF_MEDIA_10B_2:
-                result = detect_bnc(dev);
-                if (result==DETECTED_NONE) {
-                        printk(KERN_WARNING "%s: 10Base-2 (BNC) has no cable\n", dev->name);
-                        if (lp->auto_neg_cnf & IMM_BIT) /* check "ignore missing media" bit */
-                                result = DETECTED_BNC; /* Yes! I don't care if I can xmit a packet */
-                }
-		break;
-	case A_CNF_MEDIA_AUTO:
-		writereg(dev, PP_LineCTL, lp->linectl | AUTO_AUI_10BASET);
-		if (lp->adapter_cnf & A_CNF_10B_T)
-			if ((result = detect_tp(dev)) != DETECTED_NONE)
-				break;
-		if (lp->adapter_cnf & A_CNF_AUI)
-			if ((result = detect_aui(dev)) != DETECTED_NONE)
-				break;
-		if (lp->adapter_cnf & A_CNF_10B_2)
-			if ((result = detect_bnc(dev)) != DETECTED_NONE)
-				break;
-		printk(KERN_ERR "%s: no media detected\n", dev->name);
-		goto release_dma;
-	}
-	switch(result) {
-	case DETECTED_NONE:
-		printk(KERN_ERR "%s: no network cable attached to configured media\n", dev->name);
-		goto release_dma;
-	case DETECTED_RJ45H:
-		printk(KERN_INFO "%s: using half-duplex 10Base-T (RJ-45)\n", dev->name);
-		break;
-	case DETECTED_RJ45F:
-		printk(KERN_INFO "%s: using full-duplex 10Base-T (RJ-45)\n", dev->name);
-		break;
-	case DETECTED_AUI:
-		printk(KERN_INFO "%s: using 10Base-5 (AUI)\n", dev->name);
-		break;
-	case DETECTED_BNC:
-		printk(KERN_INFO "%s: using 10Base-2 (BNC)\n", dev->name);
-		break;
-	}
-
-	/* Turn on both receive and transmit operations */
-	writereg(dev, PP_LineCTL, readreg(dev, PP_LineCTL) | SERIAL_RX_ON | SERIAL_TX_ON);
-
-	/* Receive only error free packets addressed to this card */
-	lp->rx_mode = 0;
-	writereg(dev, PP_RxCTL, DEF_RX_ACCEPT);
-
-	lp->curr_rx_cfg = RX_OK_ENBL | RX_CRC_ERROR_ENBL;
-
-	if (lp->isa_config & STREAM_TRANSFER)
-		lp->curr_rx_cfg |= RX_STREAM_ENBL;
-#if ALLOW_DMA
-	set_dma_cfg(dev);
-#endif
-	writereg(dev, PP_RxCFG, lp->curr_rx_cfg);
-
-	writereg(dev, PP_TxCFG, TX_LOST_CRS_ENBL | TX_SQE_ERROR_ENBL | TX_OK_ENBL |
-		TX_LATE_COL_ENBL | TX_JBR_ENBL | TX_ANY_COL_ENBL | TX_16_COL_ENBL);
-
-	writereg(dev, PP_BufCFG, READY_FOR_TX_ENBL | RX_MISS_COUNT_OVRFLOW_ENBL |
-#if ALLOW_DMA
-		dma_bufcfg(dev) |
-#endif
-		TX_COL_COUNT_OVRFLOW_ENBL | TX_UNDERRUN_ENBL);
-
-	/* now that we've got our act together, enable everything */
-	writereg(dev, PP_BusCTL, ENABLE_IRQ
-		 | (dev->mem_start?MEMORY_ON : 0) /* turn memory on */
-#if ALLOW_DMA
-		 | dma_busctl(dev)
-#endif
-                 );
-        netif_start_queue(dev);
-	if (net_debug > 1)
-		printk("cs89x0: net_open() succeeded\n");
-	return 0;
-bad_out:
-	return ret;
-}
-
-static void net_timeout(struct net_device *dev)
-{
-	/* If we get here, some higher level has decided we are broken.
-	   There should really be a "kick me" function call instead. */
-	if (net_debug > 0) printk("%s: transmit timed out, %s?\n", dev->name,
-		   tx_done(dev) ? "IRQ conflict ?" : "network cable problem");
-	/* Try to restart the adaptor. */
-	netif_wake_queue(dev);
-}
-
-static int net_send_packet(struct sk_buff *skb, struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-
-	if (net_debug > 3) {
-		printk("%s: sent %d byte packet of type %x\n",
-			dev->name, skb->len,
-			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
-	}
-
-	/* keep the upload from being interrupted, since we
-                  ask the chip to start transmitting before the
-                  whole packet has been completely uploaded. */
-
-	spin_lock_irq(&lp->lock);
-	netif_stop_queue(dev);
-
-	/* initiate a transmit sequence */
-	writeword(dev->base_addr, TX_CMD_PORT, lp->send_cmd);
-	writeword(dev->base_addr, TX_LEN_PORT, skb->len);
-
-	/* Test to see if the chip has allocated memory for the packet */
-	if ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {
-		/*
-		 * Gasp!  It hasn't.  But that shouldn't happen since
-		 * we're waiting for TxOk, so return 1 and requeue this packet.
-		 */
-
-		spin_unlock_irq(&lp->lock);
-		if (net_debug) printk("cs89x0: Tx buffer not free!\n");
-		return 1;
-	}
-	/* Write the contents of the packet */
-	writewords(dev->base_addr, TX_FRAME_PORT,skb->data,(skb->len+1) >>1);
-	spin_unlock_irq(&lp->lock);
-	lp->stats.tx_bytes += skb->len;
-	dev->trans_start = jiffies;
-	dev_kfree_skb (skb);
-
-	/*
-	 * We DO NOT call netif_wake_queue() here.
-	 * We also DO NOT call netif_start_queue().
-	 *
-	 * Either of these would cause another bottom half run through
-	 * net_send_packet() before this packet has fully gone out.  That causes
-	 * us to hit the "Gasp!" above and the send is rescheduled.  it runs like
-	 * a dog.  We just return and wait for the Tx completion interrupt handler
-	 * to restart the netdevice layer
-	 */
-
-	return 0;
-}
-
-/* The typical workload of the driver:
-   Handle the network interface interrupts. */
-
-static irqreturn_t net_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	struct net_local *lp;
-	int ioaddr, status;
- 	int handled = 0;
-
-	ioaddr = dev->base_addr;
-	lp = netdev_priv(dev);
-
-	/* we MUST read all the events out of the ISQ, otherwise we'll never
-           get interrupted again.  As a consequence, we can't have any limit
-           on the number of times we loop in the interrupt handler.  The
-           hardware guarantees that eventually we'll run out of events.  Of
-           course, if you're on a slow machine, and packets are arriving
-           faster than you can read them off, you're screwed.  Hasta la
-           vista, baby!  */
-	while ((status = readword(dev->base_addr, ISQ_PORT))) {
-		if (net_debug > 4)printk("%s: event=%04x\n", dev->name, status);
-		handled = 1;
-		switch(status & ISQ_EVENT_MASK) {
-		case ISQ_RECEIVER_EVENT:
-			/* Got a packet(s). */
-			net_rx(dev);
-			break;
-		case ISQ_TRANSMITTER_EVENT:
-			lp->stats.tx_packets++;
-			netif_wake_queue(dev);	/* Inform upper layers. */
-			if ((status & (	TX_OK |
-					TX_LOST_CRS |
-					TX_SQE_ERROR |
-					TX_LATE_COL |
-					TX_16_COL)) != TX_OK) {
-				if ((status & TX_OK) == 0) lp->stats.tx_errors++;
-				if (status & TX_LOST_CRS) lp->stats.tx_carrier_errors++;
-				if (status & TX_SQE_ERROR) lp->stats.tx_heartbeat_errors++;
-				if (status & TX_LATE_COL) lp->stats.tx_window_errors++;
-				if (status & TX_16_COL) lp->stats.tx_aborted_errors++;
-			}
-			break;
-		case ISQ_BUFFER_EVENT:
-			if (status & READY_FOR_TX) {
-				/* we tried to transmit a packet earlier,
-                                   but inexplicably ran out of buffers.
-                                   That shouldn't happen since we only ever
-                                   load one packet.  Shrug.  Do the right
-                                   thing anyway. */
-				netif_wake_queue(dev);	/* Inform upper layers. */
-			}
-			if (status & TX_UNDERRUN) {
-				if (net_debug > 0) printk("%s: transmit underrun\n", dev->name);
-                                lp->send_underrun++;
-                                if (lp->send_underrun == 3) lp->send_cmd = TX_AFTER_381;
-                                else if (lp->send_underrun == 6) lp->send_cmd = TX_AFTER_ALL;
-				/* transmit cycle is done, although
-				   frame wasn't transmitted - this
-				   avoids having to wait for the upper
-				   layers to timeout on us, in the
-				   event of a tx underrun */
-				netif_wake_queue(dev);	/* Inform upper layers. */
-                        }
-#if ALLOW_DMA
-			if (lp->use_dma && (status & RX_DMA)) {
-				int count = readreg(dev, PP_DmaFrameCnt);
-				while(count) {
-					if (net_debug > 5)
-						printk("%s: receiving %d DMA frames\n", dev->name, count);
-					if (net_debug > 2 && count >1)
-						printk("%s: receiving %d DMA frames\n", dev->name, count);
-					dma_rx(dev);
-					if (--count == 0)
-						count = readreg(dev, PP_DmaFrameCnt);
-					if (net_debug > 2 && count > 0)
-						printk("%s: continuing with %d DMA frames\n", dev->name, count);
-				}
-			}
-#endif
-			break;
-		case ISQ_RX_MISS_EVENT:
-			lp->stats.rx_missed_errors += (status >>6);
-			break;
-		case ISQ_TX_COL_EVENT:
-			lp->stats.collisions += (status >>6);
-			break;
-		}
-	}
-	return IRQ_RETVAL(handled);
-}
-
-static void
-count_rx_errors(int status, struct net_local *lp)
-{
-	lp->stats.rx_errors++;
-	if (status & RX_RUNT) lp->stats.rx_length_errors++;
-	if (status & RX_EXTRA_DATA) lp->stats.rx_length_errors++;
-	if (status & RX_CRC_ERROR) if (!(status & (RX_EXTRA_DATA|RX_RUNT)))
-		/* per str 172 */
-		lp->stats.rx_crc_errors++;
-	if (status & RX_DRIBBLE) lp->stats.rx_frame_errors++;
-	return;
-}
-
-/* We have a good packet(s), get it/them out of the buffers. */
-static void
-net_rx(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	struct sk_buff *skb;
-	int status, length;
-
-	int ioaddr = dev->base_addr;
-	status = readword(ioaddr, RX_FRAME_PORT);
-	length = readword(ioaddr, RX_FRAME_PORT);
-
-	if ((status & RX_OK) == 0) {
-		count_rx_errors(status, lp);
-		return;
-	}
-
-	/* Malloc up new buffer. */
-	skb = dev_alloc_skb(length + 2);
-	if (skb == NULL) {
-#if 0		/* Again, this seems a cruel thing to do */
-		printk(KERN_WARNING "%s: Memory squeeze, dropping packet.\n", dev->name);
-#endif
-		lp->stats.rx_dropped++;
-		return;
-	}
-	skb_reserve(skb, 2);	/* longword align L3 header */
-
-	readwords(ioaddr, RX_FRAME_PORT, skb_put(skb, length), length >> 1);
-	if (length & 1)
-		skb->data[length-1] = readword(ioaddr, RX_FRAME_PORT);
-
-	if (net_debug > 3) {
-		printk(	"%s: received %d byte packet of type %x\n",
-			dev->name, length,
-			(skb->data[ETH_ALEN+ETH_ALEN] << 8) | skb->data[ETH_ALEN+ETH_ALEN+1]);
-	}
-
-        skb->protocol=eth_type_trans(skb,dev);
-	netif_rx(skb);
-	dev->last_rx = jiffies;
-	lp->stats.rx_packets++;
-	lp->stats.rx_bytes += length;
-}
-
-#if ALLOW_DMA
-static void release_dma_buff(struct net_local *lp)
-{
-	if (lp->dma_buff) {
-		free_pages((unsigned long)(lp->dma_buff), get_order(lp->dmasize * 1024));
-		lp->dma_buff = NULL;
-	}
-}
-#endif
-
-/* The inverse routine to net_open(). */
-static int
-net_close(struct net_device *dev)
-{
-#if ALLOW_DMA
-	struct net_local *lp = netdev_priv(dev);
-#endif
-
-	netif_stop_queue(dev);
-
-	writereg(dev, PP_RxCFG, 0);
-	writereg(dev, PP_TxCFG, 0);
-	writereg(dev, PP_BufCFG, 0);
-	writereg(dev, PP_BusCTL, 0);
-
-	free_irq(dev->irq, dev);
-
-#if ALLOW_DMA
-	if (lp->use_dma && lp->dma) {
-		free_dma(dev->dma);
-		release_dma_buff(lp);
-	}
-#endif
-
-	/* Update the statistics here. */
-	return 0;
-}
-
-/* Get the current statistics.	This may be called with the card open or
-   closed. */
-static struct net_device_stats *
-net_get_stats(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&lp->lock, flags);
-	/* Update the statistics from the device registers. */
-	lp->stats.rx_missed_errors += (readreg(dev, PP_RxMiss) >> 6);
-	lp->stats.collisions += (readreg(dev, PP_TxCol) >> 6);
-	spin_unlock_irqrestore(&lp->lock, flags);
-
-	return &lp->stats;
-}
-
-static void set_multicast_list(struct net_device *dev)
-{
-	struct net_local *lp = netdev_priv(dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&lp->lock, flags);
-	if(dev->flags&IFF_PROMISC)
-	{
-		lp->rx_mode = RX_ALL_ACCEPT;
-	}
-	else if((dev->flags&IFF_ALLMULTI)||dev->mc_list)
-	{
-		/* The multicast-accept list is initialized to accept-all, and we
-		   rely on higher-level filtering for now. */
-		lp->rx_mode = RX_MULTCAST_ACCEPT;
-	}
-	else
-		lp->rx_mode = 0;
-
-	writereg(dev, PP_RxCTL, DEF_RX_ACCEPT | lp->rx_mode);
-
-	/* in promiscuous mode, we accept errored packets, so we have to enable interrupts on them also */
-	writereg(dev, PP_RxCFG, lp->curr_rx_cfg |
-	     (lp->rx_mode == RX_ALL_ACCEPT? (RX_CRC_ERROR_ENBL|RX_RUNT_ENBL|RX_EXTRA_DATA_ENBL) : 0));
-	spin_unlock_irqrestore(&lp->lock, flags);
-}
-
-
-static int set_mac_address(struct net_device *dev, void *p)
-{
-	int i;
-	struct sockaddr *addr = p;
-
-	if (netif_running(dev))
-		return -EBUSY;
-
-	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-
-	if (net_debug) {
-		DECLARE_MAC_BUF(mac);
-		printk("%s: Setting MAC address to %s.\n",
-		       dev->name, print_mac(mac, dev->dev_addr));
-	}
-	/* set the Ethernet address */
-	for (i=0; i < ETH_ALEN/2; i++)
-		writereg(dev, PP_IA+i*2, dev->dev_addr[i*2] | (dev->dev_addr[i*2+1] << 8));
-
-	return 0;
-}
-
-#ifdef MODULE
-
-static struct net_device *dev_cs89x0;
-
-/*
- * Support the 'debug' module parm even if we're compiled for non-debug to
- * avoid breaking someone's startup scripts
- */
-
-static int io;
-static int irq;
-static int debug;
-static char media[8];
-static int duplex=-1;
-
-static int use_dma;			/* These generate unused var warnings if ALLOW_DMA = 0 */
-static int dma;
-static int dmasize=16;			/* or 64 */
-
-module_param(io, int, 0);
-module_param(irq, int, 0);
-module_param(debug, int, 0);
-module_param_string(media, media, sizeof(media), 0);
-module_param(duplex, int, 0);
-module_param(dma , int, 0);
-module_param(dmasize , int, 0);
-module_param(use_dma , int, 0);
-MODULE_PARM_DESC(io, "cs89x0 I/O base address");
-MODULE_PARM_DESC(irq, "cs89x0 IRQ number");
-#if DEBUGGING
-MODULE_PARM_DESC(debug, "cs89x0 debug level (0-6)");
-#else
-MODULE_PARM_DESC(debug, "(ignored)");
-#endif
-MODULE_PARM_DESC(media, "Set cs89x0 adapter(s) media type(s) (rj45,bnc,aui)");
-/* No other value than -1 for duplex seems to be currently interpreted */
-MODULE_PARM_DESC(duplex, "(ignored)");
-#if ALLOW_DMA
-MODULE_PARM_DESC(dma , "cs89x0 ISA DMA channel; ignored if use_dma=0");
-MODULE_PARM_DESC(dmasize , "cs89x0 DMA size in kB (16,64); ignored if use_dma=0");
-MODULE_PARM_DESC(use_dma , "cs89x0 using DMA (0-1)");
-#else
-MODULE_PARM_DESC(dma , "(ignored)");
-MODULE_PARM_DESC(dmasize , "(ignored)");
-MODULE_PARM_DESC(use_dma , "(ignored)");
-#endif
-
-MODULE_AUTHOR("Mike Cruse, Russwll Nelson <nelson@crynwr.com>, Andrew Morton <andrewm@uow.edu.au>");
-MODULE_LICENSE("GPL");
-
-
-/*
-* media=t             - specify media type
-   or media=2
-   or media=aui
-   or medai=auto
-* duplex=0            - specify forced half/full/autonegotiate duplex
-* debug=#             - debug level
-
-
-* Default Chip Configuration:
-  * DMA Burst = enabled
-  * IOCHRDY Enabled = enabled
-    * UseSA = enabled
-    * CS8900 defaults to half-duplex if not specified on command-line
-    * CS8920 defaults to autoneg if not specified on command-line
-    * Use reset defaults for other config parameters
-
-* Assumptions:
-  * media type specified is supported (circuitry is present)
-  * if memory address is > 1MB, then required mem decode hw is present
-  * if 10B-2, then agent other than driver will enable DC/DC converter
-    (hw or software util)
-
-
-*/
-
-int __init init_module(void)
-{
-	struct net_device *dev = alloc_etherdev(sizeof(struct net_local));
-	struct net_local *lp;
-	int ret = 0;
-
-#if DEBUGGING
-	net_debug = debug;
-#else
-	debug = 0;
-#endif
-	if (!dev)
-		return -ENOMEM;
-
-	dev->irq = irq;
-	dev->base_addr = io;
-	lp = netdev_priv(dev);
-
-#if ALLOW_DMA
-	if (use_dma) {
-		lp->use_dma = use_dma;
-		lp->dma = dma;
-		lp->dmasize = dmasize;
-	}
-#endif
-
-	spin_lock_init(&lp->lock);
-
-        /* boy, they'd better get these right */
-        if (!strcmp(media, "rj45"))
-		lp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;
-	else if (!strcmp(media, "aui"))
-		lp->adapter_cnf = A_CNF_MEDIA_AUI   | A_CNF_AUI;
-	else if (!strcmp(media, "bnc"))
-		lp->adapter_cnf = A_CNF_MEDIA_10B_2 | A_CNF_10B_2;
-	else
-		lp->adapter_cnf = A_CNF_MEDIA_10B_T | A_CNF_10B_T;
-
-        if (duplex==-1)
-		lp->auto_neg_cnf = AUTO_NEG_ENABLE;
-
-        if (io == 0) {
-                printk(KERN_ERR "cs89x0.c: Module autoprobing not allowed.\n");
-                printk(KERN_ERR "cs89x0.c: Append io=0xNNN\n");
-                ret = -EPERM;
-		goto out;
-        } else if (io <= 0x1ff) {
-		ret = -ENXIO;
-		goto out;
-	}
-
-#if ALLOW_DMA
-	if (use_dma && dmasize != 16 && dmasize != 64) {
-		printk(KERN_ERR "cs89x0.c: dma size must be either 16K or 64K, not %dK\n", dmasize);
-		ret = -EPERM;
-		goto out;
-	}
-#endif
-	ret = cs89x0_probe1(dev, io, 1);
-	if (ret)
-		goto out;
-
-	dev_cs89x0 = dev;
-	return 0;
-out:
-	free_netdev(dev);
-	return ret;
-}
-
-void __exit
-cleanup_module(void)
-{
-	unregister_netdev(dev_cs89x0);
-	writeword(dev_cs89x0->base_addr, ADD_PORT, PP_ChipID);
-	release_region(dev_cs89x0->base_addr, NETCARD_IO_EXTENT);
-	free_netdev(dev_cs89x0);
-}
-#endif /* MODULE */
-
-/*
- * Local variables:
- *  version-control: t
- *  kept-new-versions: 5
- *  c-indent-level: 8
- *  tab-width: 8
- * End:
- *
- */
diff -urN linux-2.6.27new/drivers/net/cs89x0.h linux-2.6.27/drivers/net/cs89x0.h
--- linux-2.6.27new/drivers/net/cs89x0.h	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/cs89x0.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,469 +0,0 @@
-/*  Copyright, 1988-1992, Russell Nelson, Crynwr Software
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, version 1.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-   */
-
-
-#define PP_ChipID 0x0000	/* offset   0h -> Corp -ID              */
-				/* offset   2h -> Model/Product Number  */
-				/* offset   3h -> Chip Revision Number  */
-
-#define PP_ISAIOB 0x0020	/*  IO base address */
-#define PP_CS8900_ISAINT 0x0022	/*  ISA interrupt select */
-#define PP_CS8920_ISAINT 0x0370	/*  ISA interrupt select */
-#define PP_CS8900_ISADMA 0x0024	/*  ISA Rec DMA channel */
-#define PP_CS8920_ISADMA 0x0374	/*  ISA Rec DMA channel */
-#define PP_ISASOF 0x0026	/*  ISA DMA offset */
-#define PP_DmaFrameCnt 0x0028	/*  ISA DMA Frame count */
-#define PP_DmaByteCnt 0x002A	/*  ISA DMA Byte count */
-#define PP_CS8900_ISAMemB 0x002C	/*  Memory base */
-#define PP_CS8920_ISAMemB 0x0348 /*  */
-
-#define PP_ISABootBase 0x0030	/*  Boot Prom base  */
-#define PP_ISABootMask 0x0034	/*  Boot Prom Mask */
-
-/* EEPROM data and command registers */
-#define PP_EECMD 0x0040		/*  NVR Interface Command register */
-#define PP_EEData 0x0042	/*  NVR Interface Data Register */
-#define PP_DebugReg 0x0044	/*  Debug Register */
-
-#define PP_RxCFG 0x0102		/*  Rx Bus config */
-#define PP_RxCTL 0x0104		/*  Receive Control Register */
-#define PP_TxCFG 0x0106		/*  Transmit Config Register */
-#define PP_TxCMD 0x0108		/*  Transmit Command Register */
-#define PP_BufCFG 0x010A	/*  Bus configuration Register */
-#define PP_LineCTL 0x0112	/*  Line Config Register */
-#define PP_SelfCTL 0x0114	/*  Self Command Register */
-#define PP_BusCTL 0x0116	/*  ISA bus control Register */
-#define PP_TestCTL 0x0118	/*  Test Register */
-#define PP_AutoNegCTL 0x011C	/*  Auto Negotiation Ctrl */
-
-#define PP_ISQ 0x0120		/*  Interrupt Status */
-#define PP_RxEvent 0x0124	/*  Rx Event Register */
-#define PP_TxEvent 0x0128	/*  Tx Event Register */
-#define PP_BufEvent 0x012C	/*  Bus Event Register */
-#define PP_RxMiss 0x0130	/*  Receive Miss Count */
-#define PP_TxCol 0x0132		/*  Transmit Collision Count */
-#define PP_LineST 0x0134	/*  Line State Register */
-#define PP_SelfST 0x0136	/*  Self State register */
-#define PP_BusST 0x0138		/*  Bus Status */
-#define PP_TDR 0x013C		/*  Time Domain Reflectometry */
-#define PP_AutoNegST 0x013E	/*  Auto Neg Status */
-#define PP_TxCommand 0x0144	/*  Tx Command */
-#define PP_TxLength 0x0146	/*  Tx Length */
-#define PP_LAF 0x0150		/*  Hash Table */
-#define PP_IA 0x0158		/*  Physical Address Register */
-
-#define PP_RxStatus 0x0400	/*  Receive start of frame */
-#define PP_RxLength 0x0402	/*  Receive Length of frame */
-#define PP_RxFrame 0x0404	/*  Receive frame pointer */
-#define PP_TxFrame 0x0A00	/*  Transmit frame pointer */
-
-/*  Primary I/O Base Address. If no I/O base is supplied by the user, then this */
-/*  can be used as the default I/O base to access the PacketPage Area. */
-#define DEFAULTIOBASE 0x0300
-#define FIRST_IO 0x020C		/*  First I/O port to check */
-#define LAST_IO 0x037C		/*  Last I/O port to check (+10h) */
-#define ADD_MASK 0x3000		/*  Mask it use of the ADD_PORT register */
-#define ADD_SIG 0x3000		/*  Expected ID signature */
-
-/* On Macs, we only need use the ISA I/O stuff until we do MEMORY_ON */
-#ifdef CONFIG_MAC
-#define LCSLOTBASE 0xfee00000
-#define MMIOBASE 0x40000
-#endif
-
-#define CHIP_EISA_ID_SIG 0x630E   /*  Product ID Code for Crystal Chip (CS8900 spec 4.3) */
-#define CHIP_EISA_ID_SIG_STR "0x630E"
-
-#ifdef IBMEIPKT
-#define EISA_ID_SIG 0x4D24	/*  IBM */
-#define PART_NO_SIG 0x1010	/*  IBM */
-#define MONGOOSE_BIT 0x0000	/*  IBM */
-#else
-#define EISA_ID_SIG 0x630E	/*  PnP Vendor ID (same as chip id for Crystal board) */
-#define PART_NO_SIG 0x4000	/*  ID code CS8920 board (PnP Vendor Product code) */
-#define MONGOOSE_BIT 0x2000	/*  PART_NO_SIG + MONGOOSE_BUT => ID of mongoose */
-#endif
-
-#define PRODUCT_ID_ADD 0x0002   /*  Address of product ID */
-
-/*  Mask to find out the types of  registers */
-#define REG_TYPE_MASK 0x001F
-
-/*  Eeprom Commands */
-#define ERSE_WR_ENBL 0x00F0
-#define ERSE_WR_DISABLE 0x0000
-
-/*  Defines Control/Config register quintuplet numbers */
-#define RX_BUF_CFG 0x0003
-#define RX_CONTROL 0x0005
-#define TX_CFG 0x0007
-#define TX_COMMAND 0x0009
-#define BUF_CFG 0x000B
-#define LINE_CONTROL 0x0013
-#define SELF_CONTROL 0x0015
-#define BUS_CONTROL 0x0017
-#define TEST_CONTROL 0x0019
-
-/*  Defines Status/Count registers quintuplet numbers */
-#define RX_EVENT 0x0004
-#define TX_EVENT 0x0008
-#define BUF_EVENT 0x000C
-#define RX_MISS_COUNT 0x0010
-#define TX_COL_COUNT 0x0012
-#define LINE_STATUS 0x0014
-#define SELF_STATUS 0x0016
-#define BUS_STATUS 0x0018
-#define TDR 0x001C
-
-/* PP_RxCFG - Receive  Configuration and Interrupt Mask bit definition -  Read/write */
-#define SKIP_1 0x0040
-#define RX_STREAM_ENBL 0x0080
-#define RX_OK_ENBL 0x0100
-#define RX_DMA_ONLY 0x0200
-#define AUTO_RX_DMA 0x0400
-#define BUFFER_CRC 0x0800
-#define RX_CRC_ERROR_ENBL 0x1000
-#define RX_RUNT_ENBL 0x2000
-#define RX_EXTRA_DATA_ENBL 0x4000
-
-/* PP_RxCTL - Receive Control bit definition - Read/write */
-#define RX_IA_HASH_ACCEPT 0x0040
-#define RX_PROM_ACCEPT 0x0080
-#define RX_OK_ACCEPT 0x0100
-#define RX_MULTCAST_ACCEPT 0x0200
-#define RX_IA_ACCEPT 0x0400
-#define RX_BROADCAST_ACCEPT 0x0800
-#define RX_BAD_CRC_ACCEPT 0x1000
-#define RX_RUNT_ACCEPT 0x2000
-#define RX_EXTRA_DATA_ACCEPT 0x4000
-#define RX_ALL_ACCEPT (RX_PROM_ACCEPT|RX_BAD_CRC_ACCEPT|RX_RUNT_ACCEPT|RX_EXTRA_DATA_ACCEPT)
-/*  Default receive mode - individually addressed, broadcast, and error free */
-#define DEF_RX_ACCEPT (RX_IA_ACCEPT | RX_BROADCAST_ACCEPT | RX_OK_ACCEPT)
-
-/* PP_TxCFG - Transmit Configuration Interrupt Mask bit definition - Read/write */
-#define TX_LOST_CRS_ENBL 0x0040
-#define TX_SQE_ERROR_ENBL 0x0080
-#define TX_OK_ENBL 0x0100
-#define TX_LATE_COL_ENBL 0x0200
-#define TX_JBR_ENBL 0x0400
-#define TX_ANY_COL_ENBL 0x0800
-#define TX_16_COL_ENBL 0x8000
-
-/* PP_TxCMD - Transmit Command bit definition - Read-only */
-#define TX_START_4_BYTES 0x0000
-#define TX_START_64_BYTES 0x0040
-#define TX_START_128_BYTES 0x0080
-#define TX_START_ALL_BYTES 0x00C0
-#define TX_FORCE 0x0100
-#define TX_ONE_COL 0x0200
-#define TX_TWO_PART_DEFF_DISABLE 0x0400
-#define TX_NO_CRC 0x1000
-#define TX_RUNT 0x2000
-
-/* PP_BufCFG - Buffer Configuration Interrupt Mask bit definition - Read/write */
-#define GENERATE_SW_INTERRUPT 0x0040
-#define RX_DMA_ENBL 0x0080
-#define READY_FOR_TX_ENBL 0x0100
-#define TX_UNDERRUN_ENBL 0x0200
-#define RX_MISS_ENBL 0x0400
-#define RX_128_BYTE_ENBL 0x0800
-#define TX_COL_COUNT_OVRFLOW_ENBL 0x1000
-#define RX_MISS_COUNT_OVRFLOW_ENBL 0x2000
-#define RX_DEST_MATCH_ENBL 0x8000
-
-/* PP_LineCTL - Line Control bit definition - Read/write */
-#define SERIAL_RX_ON 0x0040
-#define SERIAL_TX_ON 0x0080
-#define AUI_ONLY 0x0100
-#define AUTO_AUI_10BASET 0x0200
-#define MODIFIED_BACKOFF 0x0800
-#define NO_AUTO_POLARITY 0x1000
-#define TWO_PART_DEFDIS 0x2000
-#define LOW_RX_SQUELCH 0x4000
-
-/* PP_SelfCTL - Software Self Control bit definition - Read/write */
-#define POWER_ON_RESET 0x0040
-#define SW_STOP 0x0100
-#define SLEEP_ON 0x0200
-#define AUTO_WAKEUP 0x0400
-#define HCB0_ENBL 0x1000
-#define HCB1_ENBL 0x2000
-#define HCB0 0x4000
-#define HCB1 0x8000
-
-/* PP_BusCTL - ISA Bus Control bit definition - Read/write */
-#define RESET_RX_DMA 0x0040
-#define MEMORY_ON 0x0400
-#define DMA_BURST_MODE 0x0800
-#define IO_CHANNEL_READY_ON 0x1000
-#define RX_DMA_SIZE_64K 0x2000
-#define ENABLE_IRQ 0x8000
-
-/* PP_TestCTL - Test Control bit definition - Read/write */
-#define LINK_OFF 0x0080
-#define ENDEC_LOOPBACK 0x0200
-#define AUI_LOOPBACK 0x0400
-#define BACKOFF_OFF 0x0800
-#define FDX_8900 0x4000
-#define FAST_TEST 0x8000
-
-/* PP_RxEvent - Receive Event Bit definition - Read-only */
-#define RX_IA_HASHED 0x0040
-#define RX_DRIBBLE 0x0080
-#define RX_OK 0x0100
-#define RX_HASHED 0x0200
-#define RX_IA 0x0400
-#define RX_BROADCAST 0x0800
-#define RX_CRC_ERROR 0x1000
-#define RX_RUNT 0x2000
-#define RX_EXTRA_DATA 0x4000
-
-#define HASH_INDEX_MASK 0x0FC00
-
-/* PP_TxEvent - Transmit Event Bit definition - Read-only */
-#define TX_LOST_CRS 0x0040
-#define TX_SQE_ERROR 0x0080
-#define TX_OK 0x0100
-#define TX_LATE_COL 0x0200
-#define TX_JBR 0x0400
-#define TX_16_COL 0x8000
-#define TX_SEND_OK_BITS (TX_OK|TX_LOST_CRS)
-#define TX_COL_COUNT_MASK 0x7800
-
-/* PP_BufEvent - Buffer Event Bit definition - Read-only */
-#define SW_INTERRUPT 0x0040
-#define RX_DMA 0x0080
-#define READY_FOR_TX 0x0100
-#define TX_UNDERRUN 0x0200
-#define RX_MISS 0x0400
-#define RX_128_BYTE 0x0800
-#define TX_COL_OVRFLW 0x1000
-#define RX_MISS_OVRFLW 0x2000
-#define RX_DEST_MATCH 0x8000
-
-/* PP_LineST - Ethernet Line Status bit definition - Read-only */
-#define LINK_OK 0x0080
-#define AUI_ON 0x0100
-#define TENBASET_ON 0x0200
-#define POLARITY_OK 0x1000
-#define CRS_OK 0x4000
-
-/* PP_SelfST - Chip Software Status bit definition */
-#define ACTIVE_33V 0x0040
-#define INIT_DONE 0x0080
-#define SI_BUSY 0x0100
-#define EEPROM_PRESENT 0x0200
-#define EEPROM_OK 0x0400
-#define EL_PRESENT 0x0800
-#define EE_SIZE_64 0x1000
-
-/* PP_BusST - ISA Bus Status bit definition */
-#define TX_BID_ERROR 0x0080
-#define READY_FOR_TX_NOW 0x0100
-
-/* PP_AutoNegCTL - Auto Negotiation Control bit definition */
-#define RE_NEG_NOW 0x0040
-#define ALLOW_FDX 0x0080
-#define AUTO_NEG_ENABLE 0x0100
-#define NLP_ENABLE 0x0200
-#define FORCE_FDX 0x8000
-#define AUTO_NEG_BITS (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE)
-#define AUTO_NEG_MASK (FORCE_FDX|NLP_ENABLE|AUTO_NEG_ENABLE|ALLOW_FDX|RE_NEG_NOW)
-
-/* PP_AutoNegST - Auto Negotiation Status bit definition */
-#define AUTO_NEG_BUSY 0x0080
-#define FLP_LINK 0x0100
-#define FLP_LINK_GOOD 0x0800
-#define LINK_FAULT 0x1000
-#define HDX_ACTIVE 0x4000
-#define FDX_ACTIVE 0x8000
-
-/*  The following block defines the ISQ event types */
-#define ISQ_RECEIVER_EVENT 0x04
-#define ISQ_TRANSMITTER_EVENT 0x08
-#define ISQ_BUFFER_EVENT 0x0c
-#define ISQ_RX_MISS_EVENT 0x10
-#define ISQ_TX_COL_EVENT 0x12
-
-#define ISQ_EVENT_MASK 0x003F   /*  ISQ mask to find out type of event */
-#define ISQ_HIST 16		/*  small history buffer */
-#define AUTOINCREMENT 0x8000	/*  Bit mask to set bit-15 for autoincrement */
-
-#define TXRXBUFSIZE 0x0600
-#define RXDMABUFSIZE 0x8000
-#define RXDMASIZE 0x4000
-#define TXRX_LENGTH_MASK 0x07FF
-
-/*  rx options bits */
-#define RCV_WITH_RXON	1       /*  Set SerRx ON */
-#define RCV_COUNTS	2       /*  Use Framecnt1 */
-#define RCV_PONG	4       /*  Pong respondent */
-#define RCV_DONG	8       /*  Dong operation */
-#define RCV_POLLING	0x10	/*  Poll RxEvent */
-#define RCV_ISQ		0x20	/*  Use ISQ, int */
-#define RCV_AUTO_DMA	0x100	/*  Set AutoRxDMAE */
-#define RCV_DMA		0x200	/*  Set RxDMA only */
-#define RCV_DMA_ALL	0x400	/*  Copy all DMA'ed */
-#define RCV_FIXED_DATA	0x800	/*  Every frame same */
-#define RCV_IO		0x1000	/*  Use ISA IO only */
-#define RCV_MEMORY	0x2000	/*  Use ISA Memory */
-
-#define RAM_SIZE	0x1000       /*  The card has 4k bytes or RAM */
-#define PKT_START PP_TxFrame  /*  Start of packet RAM */
-
-#define RX_FRAME_PORT	0x0000
-#define TX_FRAME_PORT RX_FRAME_PORT
-#define TX_CMD_PORT	0x0004
-#define TX_NOW		0x0000       /*  Tx packet after   5 bytes copied */
-#define TX_AFTER_381	0x0040       /*  Tx packet after 381 bytes copied */
-#define TX_AFTER_ALL	0x00c0       /*  Tx packet after all bytes copied */
-#define TX_LEN_PORT	0x0006
-#define ISQ_PORT	0x0008
-#define ADD_PORT	0x000A
-#define DATA_PORT	0x000C
-
-#define EEPROM_WRITE_EN		0x00F0
-#define EEPROM_WRITE_DIS	0x0000
-#define EEPROM_WRITE_CMD	0x0100
-#define EEPROM_READ_CMD		0x0200
-
-/*  Receive Header */
-/*  Description of header of each packet in receive area of memory */
-#define RBUF_EVENT_LOW	0   /*  Low byte of RxEvent - status of received frame */
-#define RBUF_EVENT_HIGH	1   /*  High byte of RxEvent - status of received frame */
-#define RBUF_LEN_LOW	2   /*  Length of received data - low byte */
-#define RBUF_LEN_HI	3   /*  Length of received data - high byte */
-#define RBUF_HEAD_LEN	4   /*  Length of this header */
-
-#define CHIP_READ 0x1   /*  Used to mark state of the repins code (chip or dma) */
-#define DMA_READ 0x2   /*  Used to mark state of the repins code (chip or dma) */
-
-/*  for bios scan */
-/*  */
-#ifdef CSDEBUG
-/*  use these values for debugging bios scan */
-#define BIOS_START_SEG 0x00000
-#define BIOS_OFFSET_INC 0x0010
-#else
-#define BIOS_START_SEG 0x0c000
-#define BIOS_OFFSET_INC 0x0200
-#endif
-
-#define BIOS_LAST_OFFSET 0x0fc00
-
-/*  Byte offsets into the EEPROM configuration buffer */
-#define ISA_CNF_OFFSET 0x6
-#define TX_CTL_OFFSET (ISA_CNF_OFFSET + 8)			/*  8900 eeprom */
-#define AUTO_NEG_CNF_OFFSET (ISA_CNF_OFFSET + 8)		/*  8920 eeprom */
-
-  /*  the assumption here is that the bits in the eeprom are generally  */
-  /*  in the same position as those in the autonegctl register. */
-  /*  Of course the IMM bit is not in that register so it must be  */
-  /*  masked out */
-#define EE_FORCE_FDX  0x8000
-#define EE_NLP_ENABLE 0x0200
-#define EE_AUTO_NEG_ENABLE 0x0100
-#define EE_ALLOW_FDX 0x0080
-#define EE_AUTO_NEG_CNF_MASK (EE_FORCE_FDX|EE_NLP_ENABLE|EE_AUTO_NEG_ENABLE|EE_ALLOW_FDX)
-
-#define IMM_BIT 0x0040		/*  ignore missing media	 */
-
-#define ADAPTER_CNF_OFFSET (AUTO_NEG_CNF_OFFSET + 2)
-#define A_CNF_10B_T 0x0001
-#define A_CNF_AUI 0x0002
-#define A_CNF_10B_2 0x0004
-#define A_CNF_MEDIA_TYPE 0x0070
-#define A_CNF_MEDIA_AUTO 0x0070
-#define A_CNF_MEDIA_10B_T 0x0020
-#define A_CNF_MEDIA_AUI 0x0040
-#define A_CNF_MEDIA_10B_2 0x0010
-#define A_CNF_DC_DC_POLARITY 0x0080
-#define A_CNF_NO_AUTO_POLARITY 0x2000
-#define A_CNF_LOW_RX_SQUELCH 0x4000
-#define A_CNF_EXTND_10B_2 0x8000
-
-#define PACKET_PAGE_OFFSET 0x8
-
-/*  Bit definitions for the ISA configuration word from the EEPROM */
-#define INT_NO_MASK 0x000F
-#define DMA_NO_MASK 0x0070
-#define ISA_DMA_SIZE 0x0200
-#define ISA_AUTO_RxDMA 0x0400
-#define ISA_RxDMA 0x0800
-#define DMA_BURST 0x1000
-#define STREAM_TRANSFER 0x2000
-#define ANY_ISA_DMA (ISA_AUTO_RxDMA | ISA_RxDMA)
-
-/*  DMA controller registers */
-#define DMA_BASE 0x00     /*  DMA controller base */
-#define DMA_BASE_2 0x0C0    /*  DMA controller base */
-
-#define DMA_STAT 0x0D0    /*  DMA controller status register */
-#define DMA_MASK 0x0D4    /*  DMA controller mask register */
-#define DMA_MODE 0x0D6    /*  DMA controller mode register */
-#define DMA_RESETFF 0x0D8    /*  DMA controller first/last flip flop */
-
-/*  DMA data */
-#define DMA_DISABLE 0x04     /*  Disable channel n */
-#define DMA_ENABLE 0x00     /*  Enable channel n */
-/*  Demand transfers, incr. address, auto init, writes, ch. n */
-#define DMA_RX_MODE 0x14
-/*  Demand transfers, incr. address, auto init, reads, ch. n */
-#define DMA_TX_MODE 0x18
-
-#define DMA_SIZE (16*1024) /*  Size of dma buffer - 16k */
-
-#define CS8900 0x0000
-#define CS8920 0x4000
-#define CS8920M 0x6000
-#define REVISON_BITS 0x1F00
-#define EEVER_NUMBER 0x12
-#define CHKSUM_LEN 0x14
-#define CHKSUM_VAL 0x0000
-#define START_EEPROM_DATA 0x001c /*  Offset into eeprom for start of data */
-#define IRQ_MAP_EEPROM_DATA 0x0046 /*  Offset into eeprom for the IRQ map */
-#define IRQ_MAP_LEN 0x0004 /*  No of bytes to read for the IRQ map */
-#define PNP_IRQ_FRMT 0x0022 /*  PNP small item IRQ format */
-#ifdef CONFIG_SH_HICOSH4
-#define CS8900_IRQ_MAP 0x0002 /* HiCO-SH4 board has its IRQ on #1 */
-#else
-#define CS8900_IRQ_MAP 0x1c20 /*  This IRQ map is fixed */
-#endif
-
-#define CS8920_NO_INTS 0x0F   /*  Max CS8920 interrupt select # */
-
-#define PNP_ADD_PORT 0x0279
-#define PNP_WRITE_PORT 0x0A79
-
-#define GET_PNP_ISA_STRUCT 0x40
-#define PNP_ISA_STRUCT_LEN 0x06
-#define PNP_CSN_CNT_OFF 0x01
-#define PNP_RD_PORT_OFF 0x02
-#define PNP_FUNCTION_OK 0x00
-#define PNP_WAKE 0x03
-#define PNP_RSRC_DATA 0x04
-#define PNP_RSRC_READY 0x01
-#define PNP_STATUS 0x05
-#define PNP_ACTIVATE 0x30
-#define PNP_CNF_IO_H 0x60
-#define PNP_CNF_IO_L 0x61
-#define PNP_CNF_INT 0x70
-#define PNP_CNF_DMA 0x74
-#define PNP_CNF_MEM 0x48
-
-#define BIT0 1
-#define BIT15 0x8000
-
diff -urN linux-2.6.27new/drivers/net/Kconfig linux-2.6.27/drivers/net/Kconfig
--- linux-2.6.27new/drivers/net/Kconfig	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/Kconfig	2009-07-23 17:08:11.000000000 +0800
@@ -1252,7 +1252,7 @@
 
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
-	depends on ISA || EISA || PCI
+	depends on ISA || EISA || PCI || MACH_AKAE2440
 	help
 	  This is another class of network cards which attach directly to the
 	  bus. If you have one of those, say Y and read the Ethernet-HOWTO,
@@ -1384,19 +1384,6 @@
 
 	  If in doubt, say N.
 
-config CS89x0
-	tristate "CS89x0 support"
-	depends on NET_PCI && (ISA || MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X)
-	---help---
-	  Support for CS89x0 chipset based Ethernet cards. If you have a
-	  network (Ethernet) card of this type, say Y and read the
-	  Ethernet-HOWTO, available from
-	  <http://www.tldp.org/docs.html#howto> as well as
-	  <file:Documentation/networking/cs89x0.txt>.
-
-	  To compile this driver as a module, choose M here. The module
-	  will be called cs89x0.
-
 config TC35815
 	tristate "TOSHIBA TC35815 Ethernet support"
 	depends on NET_PCI && PCI && MIPS
diff -urN linux-2.6.27new/drivers/net/Makefile linux-2.6.27/drivers/net/Makefile
--- linux-2.6.27new/drivers/net/Makefile	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/drivers/net/Makefile	2009-07-23 17:08:11.000000000 +0800
@@ -201,7 +201,7 @@
 obj-$(CONFIG_A2065) += a2065.o
 obj-$(CONFIG_HYDRA) += hydra.o
 obj-$(CONFIG_ARIADNE) += ariadne.o
-obj-$(CONFIG_CS89x0) += cs89x0.o
+#obj-$(CONFIG_CS89x0) += cs89x0.o
 obj-$(CONFIG_MACSONIC) += macsonic.o
 obj-$(CONFIG_MACMACE) += macmace.o
 obj-$(CONFIG_MAC89x0) += mac89x0.o
diff -urN linux-2.6.27new/fs/yaffs2/Kconfig linux-2.6.27/fs/yaffs2/Kconfig
--- linux-2.6.27new/fs/yaffs2/Kconfig	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/Kconfig	2009-07-23 17:08:11.000000000 +0800
@@ -5,7 +5,7 @@
 config YAFFS_FS
 	tristate "YAFFS2 file system support"
 	default n
-	depends on MTD
+	depends on MTD_BLOCK
 	select YAFFS_YAFFS1
 	select YAFFS_YAFFS2
 	help
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_checkptrw.c linux-2.6.27/fs/yaffs2/yaffs_checkptrw.c
--- linux-2.6.27new/fs/yaffs2/yaffs_checkptrw.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_checkptrw.c	2009-07-23 17:08:11.000000000 +0800
@@ -12,7 +12,7 @@
  */
 
 const char *yaffs_checkptrw_c_version =
-    "$Id$";
+    "$Id: yaffs_checkptrw.c,v 1.17 2008/08/12 22:51:57 charles Exp $";
 
 
 #include "yaffs_checkptrw.h"
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_ecc.c linux-2.6.27/fs/yaffs2/yaffs_ecc.c
--- linux-2.6.27new/fs/yaffs2/yaffs_ecc.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_ecc.c	2009-07-23 17:08:11.000000000 +0800
@@ -29,7 +29,7 @@
  */
 
 const char *yaffs_ecc_c_version =
-    "$Id$";
+    "$Id: yaffs_ecc.c,v 1.10 2007/12/13 15:35:17 wookey Exp $";
 
 #include "yportenv.h"
 
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_fs.c linux-2.6.27/fs/yaffs2/yaffs_fs.c
--- linux-2.6.27new/fs/yaffs2/yaffs_fs.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_fs.c	2009-07-23 17:08:11.000000000 +0800
@@ -32,7 +32,7 @@
  */
 
 const char *yaffs_fs_c_version =
-    "$Id$";
+    "$Id: yaffs_fs.c,v 1.75 2009/03/05 01:45:28 charles Exp $";
 extern const char *yaffs_guts_c_version;
 
 #include <linux/version.h>
@@ -91,6 +91,23 @@
 #define WRITE_SIZE(mtd) (mtd)->oobblock
 #endif
 
+#if(LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result,block_size);
+	return (uint32_t)result;
+}
+#else
+#define YCALCBLOCKS(s,b) ((s)/(b))
+#endif
+
 #include <asm/uaccess.h>
 
 #include "yportenv.h"
@@ -150,6 +167,8 @@
 
 static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
 				loff_t * pos);
+static ssize_t yaffs_hold_space(struct file *f);
+static void yaffs_release_space(struct file *f);
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))
 static int yaffs_file_flush(struct file *file, fl_owner_t id);
@@ -218,10 +237,22 @@
 #else
 static int yaffs_writepage(struct page *page);
 #endif
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END != 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+                             loff_t pos, unsigned len, unsigned flags,
+                          struct page **pagep, void **fsdata);
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata);
+#else
 static int yaffs_prepare_write(struct file *f, struct page *pg,
 			       unsigned offset, unsigned to);
 static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
 			      unsigned to);
+                                                                                                
+#endif
 
 static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
 			  int buflen);
@@ -234,8 +265,13 @@
 static struct address_space_operations yaffs_file_address_operations = {
 	.readpage = yaffs_readpage,
 	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
 	.prepare_write = yaffs_prepare_write,
 	.commit_write = yaffs_commit_write,
+#endif
 };
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
@@ -249,6 +285,7 @@
 	.fsync = yaffs_sync_object,
 	.splice_read = generic_file_splice_read,
 	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
 };
 
 #elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))
@@ -325,14 +362,16 @@
 
 static void yaffs_GrossLock(yaffs_Device * dev)
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs locking\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs locking %p\n",current));
 
 	down(&dev->grossLock);
+        T(YAFFS_TRACE_OS, ( "yaffs locked %p\n",current));
+	
 }
 
 static void yaffs_GrossUnlock(yaffs_Device * dev)
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs unlocking\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs unlocking %p\n",current));
 	up(&dev->grossLock);
 
 }
@@ -413,7 +452,7 @@
 	yaffs_GrossLock(dev);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_lookup for %d:%s\n",
+	  ( "yaffs_lookup for %d:%s\n",
 	   yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));
 
 	obj =
@@ -427,13 +466,13 @@
 
 	if (obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_lookup found %d\n", obj->objectId));
+		  ( "yaffs_lookup found %d\n", obj->objectId));
 
 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
 
 		if (inode) {
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG "yaffs_loookup dentry \n"));
+			  ( "yaffs_loookup dentry \n"));
 /* #if 0 asserted by NCB for 2.5/6 compatability - falls through to
  * d_add even if NULL inode */
 #if 0
@@ -446,7 +485,7 @@
 		}
 
 	} else {
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_lookup not found\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_lookup not found\n"));
 
 	}
 
@@ -527,7 +566,7 @@
 	if (obj) {
 		dev = obj->myDev;
 		yaffs_GrossLock(dev);
-		yaffs_DeleteFile(obj);
+		yaffs_DeleteObject(obj);
 		yaffs_GrossUnlock(dev);
 	}
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
@@ -547,7 +586,7 @@
 	yaffs_Device *dev = obj->myDev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_file_flush object %d (%s)\n", obj->objectId,
+	  ( "yaffs_file_flush object %d (%s)\n", obj->objectId,
 	   obj->dirty ? "dirty" : "clean"));
 
 	yaffs_GrossLock(dev);
@@ -569,7 +608,7 @@
 
 	yaffs_Device *dev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage at %08x, size %08x\n",
+	T(YAFFS_TRACE_OS, ( "yaffs_readpage at %08x, size %08x\n",
 			   (unsigned)(pg->index << PAGE_CACHE_SHIFT),
 			   (unsigned)PAGE_CACHE_SIZE));
 
@@ -609,7 +648,7 @@
 	flush_dcache_page(pg);
 	kunmap(pg);
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage done\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_readpage done\n"));
 	return ret;
 }
 
@@ -650,12 +689,12 @@
 
 	if (offset > inode->i_size) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_writepage at %08x, inode size = %08x!!!\n",
 		   (unsigned)(page->index << PAGE_CACHE_SHIFT),
 		   (unsigned)inode->i_size));
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "                -> don't care!!\n"));
+		  ( "                -> don't care!!\n"));
 		unlock_page(page);
 		return 0;
 	}
@@ -677,10 +716,10 @@
 	yaffs_GrossLock(obj->myDev);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_writepage at %08x, size %08x\n",
+	  ( "yaffs_writepage at %08x, size %08x\n",
 	   (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "writepag0: obj = %05x, ino = %05x\n",
+	  ( "writepag0: obj = %05x, ino = %05x\n",
 	   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
 
 	nWritten =
@@ -688,7 +727,7 @@
 				  nBytes, 0);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "writepag1: obj = %05x, ino = %05x\n",
+	  ( "writepag1: obj = %05x, ino = %05x\n",
 	   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));
 
 	yaffs_GrossUnlock(obj->myDev);
@@ -701,17 +740,120 @@
 	return (nWritten == nBytes) ? 0 : -ENOSPC;
 }
 
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+                             loff_t pos, unsigned len, unsigned flags,
+                          struct page **pagep, void **fsdata)
+
+{
+	struct page *pg = NULL;
+        pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+        uint32_t offset = pos & (PAGE_CACHE_SIZE - 1);
+        uint32_t to = offset + len;
+        
+        int ret = 0;
+        int space_held = 0;
+        
+	T(YAFFS_TRACE_OS, ( "start yaffs_write_begin\n"));
+	/* Get a page */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
+	pg = grab_cache_page_write_begin(mapping,index,flags);
+#else
+	pg = __grab_cache_page(mapping,index);
+#endif
+
+	*pagep = pg;	
+	if(!pg){
+		ret =  -ENOMEM;
+		goto out;
+	}
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+	
+	if(!space_held){
+		ret = -ENOSPC;
+		goto out;
+	}
+		
+	/* Update page if required */
+	
+	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
+		ret = yaffs_readpage_nolock(filp, pg);
+	
+	if(ret)
+		goto out;
+
+	/* Happy path return */
+	T(YAFFS_TRACE_OS, ( "end yaffs_write_begin - ok\n"));
+		
+	return 0;
+		
+out:
+	T(YAFFS_TRACE_OS, ( "end yaffs_write_begin fail returning %d\n",ret));
+	if(space_held){
+		yaffs_release_space(filp);
+	}
+	if(pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
 static int yaffs_prepare_write(struct file *f, struct page *pg,
 			       unsigned offset, unsigned to)
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_prepair_write\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_prepair_write\n"));
 	if (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))
 		return yaffs_readpage_nolock(f, pg);
-
 	return 0;
 
 }
+#endif
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+        uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE -1); 
+
+
+	
+	kva=kmap(pg);
+	addr = kva + offset_into_page;
+
+	T(YAFFS_TRACE_OS,
+	  ( "yaffs_write_end addr %x pos %x nBytes %d\n", (unsigned) addr,
+	   (int)pos, copied));
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		T(YAFFS_TRACE_OS,
+		  (
+		   "yaffs_write_end not same size ret %d  copied %d\n",
+		   ret, copied ));
+		SetPageError(pg);
+		ClearPageUptodate(pg);
+	} else {
+		SetPageUptodate(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
 
 static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
 			      unsigned to)
@@ -729,17 +871,17 @@
 	kva=kmap(pg);
 	addr = kva + offset;
 
-	saddr = (unsigned)addr;
+	saddr = (unsigned) addr;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_commit_write addr %x pos %x nBytes %d\n", saddr,
+	  ( "yaffs_commit_write addr %x pos %x nBytes %d\n", saddr,
 	   spos, nBytes));
 
 	nWritten = yaffs_file_write(f, addr, nBytes, &pos);
 
 	if (nWritten != nBytes) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_commit_write not same size nWritten %d  nBytes %d\n",
 		   nWritten, nBytes));
 		SetPageError(pg);
@@ -751,12 +893,14 @@
 	kunmap(pg);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_commit_write returning %d\n",
+	  ( "yaffs_commit_write returning %d\n",
 	   nWritten == nBytes ? 0 : nWritten));
 
 	return nWritten == nBytes ? 0 : nWritten;
 
 }
+#endif
+
 
 static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)
 {
@@ -825,7 +969,7 @@
 		inode->i_nlink = yaffs_GetObjectLinkCount(obj);
 
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
+		  (
 		   "yaffs_FillInode mode %x uid %d gid %d size %d count %d\n",
 		   inode->i_mode, inode->i_uid, inode->i_gid,
 		   (int)inode->i_size, atomic_read(&inode->i_count)));
@@ -861,7 +1005,7 @@
 
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_FileInode invalid parameters\n"));
+		  ( "yaffs_FileInode invalid parameters\n"));
 	}
 
 }
@@ -873,20 +1017,20 @@
 
 	if (!sb) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_get_inode for NULL super_block!!\n"));
+		  ( "yaffs_get_inode for NULL super_block!!\n"));
 		return NULL;
 
 	}
 
 	if (!obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_get_inode for NULL object!!\n"));
+		  ( "yaffs_get_inode for NULL object!!\n"));
 		return NULL;
 
 	}
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_get_inode for object %d\n", obj->objectId));
+	  ( "yaffs_get_inode for object %d\n", obj->objectId));
 
 	inode = Y_IGET(sb, obj->objectId);
 	if(IS_ERR(inode))
@@ -923,11 +1067,11 @@
 
 	if (!obj) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_file_write: hey obj is null!\n"));
+		  ( "yaffs_file_write: hey obj is null!\n"));
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG
-		   "yaffs_file_write about to write writing %d bytes"
+		  (
+		   "yaffs_file_write about to write writing %zu bytes"
 		   "to object %d at %d\n",
 		   n, obj->objectId, ipos));
 	}
@@ -935,7 +1079,7 @@
 	nWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_file_write writing %d bytes, %d written at %d\n",
+	  ( "yaffs_file_write writing %zu bytes, %d written at %d\n",
 	   n, nWritten, ipos));
 	if (nWritten > 0) {
 		ipos += nWritten;
@@ -945,7 +1089,7 @@
 			inode->i_blocks = (ipos + 511) >> 9;
 
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG
+			  (
 			   "yaffs_file_write size updated to %d bytes, "
 			   "%d blocks\n",
 			   ipos, (int)(inode->i_blocks)));
@@ -956,6 +1100,48 @@
 	return nWritten == 0 ? -ENOSPC : nWritten;
 }
 
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	
+	int nFreeChunks;
+
+	
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	nFreeChunks = yaffs_GetNumberOfFreeChunks(dev);
+	
+	yaffs_GrossUnlock(dev);
+
+	return (nFreeChunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	yaffs_Object *obj;
+	yaffs_Device *dev;
+	
+	
+	obj = yaffs_DentryToObject(f->f_dentry);
+
+	dev = obj->myDev;
+
+	yaffs_GrossLock(dev);
+
+	
+	yaffs_GrossUnlock(dev);
+
+}
+
 static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
 {
 	yaffs_Object *obj;
@@ -978,7 +1164,7 @@
 
 	if (offset == 0) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_readdir: entry . ino %d \n",
+		  ( "yaffs_readdir: entry . ino %d \n",
 		   (int)inode->i_ino));
 		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR)
 		    < 0) {
@@ -989,7 +1175,7 @@
 	}
 	if (offset == 1) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_readdir: entry .. ino %d \n",
+		  ( "yaffs_readdir: entry .. ino %d \n",
 		   (int)f->f_dentry->d_parent->d_inode->i_ino));
 		if (filldir
 		    (dirent, "..", 2, offset,
@@ -1019,7 +1205,7 @@
 			yaffs_GetObjectName(l, name,
 					    YAFFS_MAX_NAME_LENGTH + 1);
 			T(YAFFS_TRACE_OS,
-			  (KERN_DEBUG "yaffs_readdir: %s inode %d\n", name,
+			  ( "yaffs_readdir: %s inode %d\n", name,
 			   yaffs_GetObjectInode(l)));
 
 			if (filldir(dirent,
@@ -1048,6 +1234,13 @@
 /*
  * File creation. Allocate an inode, and we're done..
  */
+ 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#define YCRED(x) x
+#else
+#define YCRED(x) x->cred
+#endif
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
 		       dev_t rdev)
@@ -1064,19 +1257,19 @@
 	yaffs_Object *parent = yaffs_InodeToObject(dir);
 
 	int error = -ENOSPC;
-	uid_t uid = current->fsuid;
-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
 	if((dir->i_mode & S_ISGID) && S_ISDIR(mode))
 		mode |= S_ISGID;
 
 	if (parent) {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: parent object %d type %d\n",
+		  ( "yaffs_mknod: parent object %d type %d\n",
 		   parent->objectId, parent->variantType));
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: could not get parent object\n"));
+		  ( "yaffs_mknod: could not get parent object\n"));
 		return -EPERM;
 	}
 
@@ -1091,7 +1284,7 @@
 	switch (mode & S_IFMT) {
 	default:
 		/* Special (socket, fifo, device...) */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG
+		T(YAFFS_TRACE_OS, (
 				   "yaffs_mknod: making special\n"));
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))
 		obj =
@@ -1104,20 +1297,20 @@
 #endif
 		break;
 	case S_IFREG:		/* file          */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_mknod: making file\n"));
 		obj =
 		    yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,
 				    gid);
 		break;
 	case S_IFDIR:		/* directory */
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod: making directory\n"));
+		  ( "yaffs_mknod: making directory\n"));
 		obj =
 		    yaffs_MknodDirectory(parent, dentry->d_name.name, mode,
 					 uid, gid);
 		break;
 	case S_IFLNK:		/* symlink */
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\n"));
+		T(YAFFS_TRACE_OS, ( "yaffs_mknod: making symlink\n"));
 		obj = NULL;	/* Do we ever get here? */
 		break;
 	}
@@ -1129,12 +1322,12 @@
 		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
 		d_instantiate(dentry, inode);
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod created object %d count = %d\n",
+		  ( "yaffs_mknod created object %d count = %d\n",
 		   obj->objectId, atomic_read(&inode->i_count)));
 		error = 0;
 	} else {
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_mknod failed making object\n"));
+		  ( "yaffs_mknod failed making object\n"));
 		error = -ENOMEM;
 	}
 
@@ -1144,7 +1337,7 @@
 static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int retVal;
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mkdir\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_mkdir\n"));
 	retVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
 #if 0
 	/* attempt to fix dir bug - didn't work */
@@ -1162,7 +1355,7 @@
 static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
 #endif
 {
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_create\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_create\n"));
 	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
 }
 
@@ -1173,7 +1366,7 @@
 	yaffs_Device *dev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_unlink %d:%s\n", (int)(dir->i_ino),
+	  ( "yaffs_unlink %d:%s\n", (int)(dir->i_ino),
 	   dentry->d_name.name));
 
 	dev = yaffs_InodeToObject(dir)->myDev;
@@ -1204,7 +1397,7 @@
 	yaffs_Object *link = NULL;
 	yaffs_Device *dev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_link\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_link\n"));
 
 	obj = yaffs_InodeToObject(inode);
 	dev = obj->myDev;
@@ -1223,7 +1416,7 @@
 		d_instantiate(dentry, old_dentry->d_inode);
 		atomic_inc(&old_dentry->d_inode->i_count);
 		T(YAFFS_TRACE_OS,
-		  (KERN_DEBUG "yaffs_link link count %d i_count %d\n",
+		  ( "yaffs_link link count %d i_count %d\n",
 		   old_dentry->d_inode->i_nlink,
 		   atomic_read(&old_dentry->d_inode->i_count)));
 
@@ -1244,10 +1437,10 @@
 {
 	yaffs_Object *obj;
 	yaffs_Device *dev;
-	uid_t uid = current->fsuid;
-	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;
+	uid_t uid = YCRED(current)->fsuid;
+	gid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : YCRED(current)->fsgid;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_symlink\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_symlink\n"));
 
 	dev = yaffs_InodeToObject(dir)->myDev;
 	yaffs_GrossLock(dev);
@@ -1261,10 +1454,10 @@
 
 		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
 		d_instantiate(dentry, inode);
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "symlink created OK\n"));
+		T(YAFFS_TRACE_OS, ( "symlink created OK\n"));
 		return 0;
 	} else {
-		T(YAFFS_TRACE_OS, (KERN_DEBUG "symlink not created\n"));
+		T(YAFFS_TRACE_OS, ( "symlink not created\n"));
 
 	}
 
@@ -1282,7 +1475,7 @@
 
 	dev = obj->myDev;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_object\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_sync_object\n"));
 	yaffs_GrossLock(dev);
 	yaffs_FlushFile(obj, 1);
 	yaffs_GrossUnlock(dev);
@@ -1301,7 +1494,7 @@
 	int retVal = YAFFS_FAIL;
 	yaffs_Object *target;
 
-        T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_rename\n"));
+        T(YAFFS_TRACE_OS, ( "yaffs_rename\n"));
 	dev = yaffs_InodeToObject(old_dir)->myDev;
 
 	yaffs_GrossLock(dev);
@@ -1317,13 +1510,13 @@
 	    target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&
 	    !ylist_empty(&target->variant.directoryVariant.children)) {
 
-	        T(YAFFS_TRACE_OS, (KERN_DEBUG "target is non-empty dir\n"));
+	        T(YAFFS_TRACE_OS, ( "target is non-empty dir\n"));
 
 		retVal = YAFFS_FAIL;
 	} else {
 
 		/* Now does unlinking internally using shadowing mechanism */
-	        T(YAFFS_TRACE_OS, (KERN_DEBUG "calling yaffs_RenameObject\n"));
+	        T(YAFFS_TRACE_OS, ( "calling yaffs_RenameObject\n"));
 
 		retVal =
 		    yaffs_RenameObject(yaffs_InodeToObject(old_dir),
@@ -1354,7 +1547,7 @@
 	yaffs_Device *dev;
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_setattr of object %d\n",
+	  ( "yaffs_setattr of object %d\n",
 	   yaffs_InodeToObject(inode)->objectId));
 
 	if ((error = inode_change_ok(inode, attr)) == 0) {
@@ -1389,7 +1582,7 @@
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
 #endif
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_statfs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_statfs\n"));
 
 	yaffs_GrossLock(dev);
 
@@ -1450,7 +1643,7 @@
 {
 
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_do_sync_fs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_do_sync_fs\n"));
 
 	if(sb->s_dirt) {
 		yaffs_GrossLock(dev);
@@ -1475,7 +1668,7 @@
 #endif
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_write_super\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_write_super\n"));
 	if (yaffs_auto_checkpoint >= 2)
 		yaffs_do_sync_fs(sb);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))
@@ -1491,7 +1684,7 @@
 #endif
 {
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_fs\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_sync_fs\n"));
 
 	if (yaffs_auto_checkpoint >= 1)
 		yaffs_do_sync_fs(sb);
@@ -1509,7 +1702,7 @@
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_iget for %lu\n", ino));
+	  ( "yaffs_iget for %lu\n", ino));
 
 	inode = iget_locked(sb, ino);
 	if (!inode)
@@ -1547,7 +1740,7 @@
 	yaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);
 
 	T(YAFFS_TRACE_OS,
-	  (KERN_DEBUG "yaffs_read_inode for %d\n", (int)inode->i_ino));
+	  ( "yaffs_read_inode for %d\n", (int)inode->i_ino));
 
 	yaffs_GrossLock(dev);
 
@@ -1571,7 +1764,7 @@
 		struct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;
 
 		T(YAFFS_TRACE_OS,
-			(KERN_DEBUG "yaffs_remount_fs: %s: RO\n", dev->name ));
+			( "yaffs_remount_fs: %s: RO\n", dev->name ));
 
 		yaffs_GrossLock(dev);
 
@@ -1586,7 +1779,7 @@
 	}
 	else {
 		T(YAFFS_TRACE_OS,
-			(KERN_DEBUG "yaffs_remount_fs: %s: RW\n", dev->name ));
+			( "yaffs_remount_fs: %s: RW\n", dev->name ));
 	}
 
 	return 0;
@@ -1597,7 +1790,7 @@
 {
 	yaffs_Device *dev = yaffs_SuperToDevice(sb);
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_put_super\n"));
+	T(YAFFS_TRACE_OS, ( "yaffs_put_super\n"));
 
 	yaffs_GrossLock(dev);
 
@@ -1642,7 +1835,7 @@
 {
 	struct super_block *sb = (struct super_block *)vsb;
 
-	T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_MarkSuperBlockDirty() sb = %p\n",sb));
+	T(YAFFS_TRACE_OS, ( "yaffs_MarkSuperBlockDirty() sb = %p\n",sb));
 	if(sb)
 		sb->s_dirt = 1;
 }
@@ -1785,7 +1978,11 @@
 	T(YAFFS_TRACE_OS, (" %s %d\n", WRITE_SIZE_STR, WRITE_SIZE(mtd)));
 	T(YAFFS_TRACE_OS, (" oobsize %d\n", mtd->oobsize));
 	T(YAFFS_TRACE_OS, (" erasesize %d\n", mtd->erasesize));
-	T(YAFFS_TRACE_OS, (" size %d\n", mtd->size));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	T(YAFFS_TRACE_OS, (" size %u\n", mtd->size));
+#else
+	T(YAFFS_TRACE_OS, (" size %lld\n", mtd->size));
+#endif
 
 #ifdef CONFIG_YAFFS_AUTO_YAFFS2
 
@@ -1882,7 +2079,8 @@
 
 	/* Set up the memory size parameters.... */
 
-	nBlocks = mtd->size / (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);
+	nBlocks = YCALCBLOCKS(mtd->size ,(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
 	dev->startBlock = 0;
 	dev->endBlock = nBlocks - 1;
 	dev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;
@@ -1908,7 +2106,7 @@
 		dev->totalBytesPerChunk = mtd->oobblock;
 		dev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;
 #endif
-		nBlocks = mtd->size / mtd->erasesize;
+		nBlocks = YCALCBLOCKS(mtd->size,mtd->erasesize);
 
 		dev->startBlock = 0;
 		dev->endBlock = nBlocks - 1;
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_guts.c linux-2.6.27/fs/yaffs2/yaffs_guts.c
--- linux-2.6.27new/fs/yaffs2/yaffs_guts.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_guts.c	2009-07-23 17:08:11.000000000 +0800
@@ -12,7 +12,7 @@
  */
 
 const char *yaffs_guts_c_version =
-    "$Id$";
+    "$Id: yaffs_guts.c,v 1.80 2009/03/05 21:46:46 charles Exp $";
 
 #include "yportenv.h"
 
@@ -33,11 +33,6 @@
 #include "yaffs_packedtags2.h"
 
 
-#ifdef CONFIG_YAFFS_WINCE
-void yfsd_LockYAFFS(BOOL fsLockOnly);
-void yfsd_UnlockYAFFS(BOOL fsLockOnly);
-#endif
-
 #define YAFFS_PASSIVE_GC_CHUNKS 2
 
 #include "yaffs_ecc.h"
@@ -84,7 +79,6 @@
 				  int chunkInNAND);
 
 static int yaffs_UnlinkWorker(yaffs_Object * obj);
-static void yaffs_DestroyObject(yaffs_Object * obj);
 
 static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,
 			   int chunkInObject);
@@ -97,6 +91,7 @@
 
 static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);
 
+static void yaffs_VerifyDirectory(yaffs_Object *directory);
 #ifdef YAFFS_PARANOID
 static int yaffs_CheckFileSanity(yaffs_Object * in);
 #else
@@ -405,14 +400,11 @@
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
 }
 
-#if 0
 static int yaffs_SkipFullVerification(yaffs_Device *dev)
 {
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));
 }
 
-#endif
-
 static int yaffs_SkipNANDVerification(yaffs_Device *dev)
 {
 	return !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));
@@ -440,7 +432,7 @@
 		return;
 		
 	/* Report illegal runtime states */
-	if(bi->blockState <0 || bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
+	if(bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)
 		T(YAFFS_TRACE_VERIFY,(TSTR("Block %d has undefined state %d"TENDSTR),n,bi->blockState));
 		
 	switch(bi->blockState){
@@ -484,9 +476,10 @@
 	yaffs_VerifyBlock(dev,bi,n);
 	
 	/* After collection the block should be in the erased state */
-	/* TODO: This will need to change if we do partial gc */
+	/* This will need to change if we do partial gc */
 	
-	if(bi->blockState != YAFFS_BLOCK_STATE_EMPTY){
+	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING &&
+	   bi->blockState != YAFFS_BLOCK_STATE_EMPTY){
 		T(YAFFS_TRACE_ERROR,(TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),
 			n,bi->blockState));
 	}
@@ -509,7 +502,7 @@
 		yaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);
 		yaffs_VerifyBlock(dev,bi,i);
 
-		if(bi->blockState >=0 && bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
+		if(bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)
 			nBlocksPerState[bi->blockState]++;
 		else
 			nIllegalBlockStates++;
@@ -553,7 +546,7 @@
  */
 static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)
 {
-	if(yaffs_SkipVerification(obj->myDev))
+	if(obj && yaffs_SkipVerification(obj->myDev))
 		return;
 		
 	if(!(tags && obj && oh)){
@@ -628,7 +621,6 @@
 				}
 			}
 		} else if (level == 0) {
-			int i;
 			yaffs_ExtendedTags tags;
 			__u32 objectId = obj->objectId;
 			
@@ -668,7 +660,10 @@
 	yaffs_Tnode *tn;
 	__u32 objectId;
 	
-	if(obj && yaffs_SkipVerification(obj->myDev))
+	if(!obj)
+		return;
+
+	if(yaffs_SkipVerification(obj->myDev))
 		return;
 	
 	dev = obj->myDev;
@@ -719,12 +714,6 @@
 
 }
 
-static void yaffs_VerifyDirectory(yaffs_Object *obj)
-{
-	if(obj && yaffs_SkipVerification(obj->myDev))
-		return;
-	
-}
 
 static void yaffs_VerifyHardLink(yaffs_Object *obj)
 {
@@ -756,10 +745,15 @@
 	__u32 chunkMax;
 	
 	__u32 chunkIdOk;
-	__u32 chunkIsLive;
+	__u32 chunkInRange;
+	__u32 chunkShouldNotBeDeleted;
+	__u32 chunkValid; 
 	
 	if(!obj)
 		return;
+		
+	if(obj->beingCreated)
+		return;
 	
 	dev = obj->myDev;
 	
@@ -771,21 +765,24 @@
 	chunkMin = dev->internalStartBlock * dev->nChunksPerBlock;
 	chunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;
 
-	chunkIdOk = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
-	chunkIsLive = chunkIdOk &&
+	chunkInRange = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);
+	chunkIdOk = chunkInRange || obj->hdrChunk == 0;
+	chunkValid  =  chunkInRange &&
 			yaffs_CheckChunkBit(dev,
 					    obj->hdrChunk / dev->nChunksPerBlock,
 					    obj->hdrChunk % dev->nChunksPerBlock);
+	chunkShouldNotBeDeleted = chunkInRange && !chunkValid;
+
 	if(!obj->fake &&
-	    (!chunkIdOk || !chunkIsLive)) {
+	    (!chunkIdOk || chunkShouldNotBeDeleted)) {
 	   T(YAFFS_TRACE_VERIFY,
 	   (TSTR("Obj %d has chunkId %d %s %s"TENDSTR),
 	   obj->objectId,obj->hdrChunk,
 	   chunkIdOk ? "" : ",out of range",
-	   chunkIsLive || !chunkIdOk ? "" : ",marked as deleted"));
+	   chunkShouldNotBeDeleted ? ",marked as deleted" : ""));
 	}
 	
-	if(chunkIdOk && chunkIsLive &&!yaffs_SkipNANDVerification(dev)) {
+	if(chunkValid &&!yaffs_SkipNANDVerification(dev)) {
 		yaffs_ExtendedTags tags;
 		yaffs_ObjectHeader *oh;
 		__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);
@@ -1053,7 +1050,7 @@
 			if (dev->writeChunkWithTagsToNAND(dev, chunkId -
 			    dev->chunkOffset, buffer, &tags) != YAFFS_OK)
 				T(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Failed to "
-					"write bad block marker to block %d"
+					TCONT("write bad block marker to block %d")
 					TENDSTR), blockInNAND));
 
 			yaffs_ReleaseTempBuffer(dev, buffer, __LINE__);
@@ -1129,7 +1126,7 @@
 	__u16 sum = 0;
 	__u16 i = 1;
 
-	YUCHAR *bname = (YUCHAR *) name;
+	const YUCHAR *bname = (const YUCHAR *) name;
 	if (bname) {
 		while ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {
 
@@ -1148,6 +1145,7 @@
 static void yaffs_SetObjectName(yaffs_Object * obj, const YCHAR * name)
 {
 #ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM
+	memset(obj->shortName,0,sizeof (YCHAR) * (YAFFS_SHORT_NAME_LENGTH+1)); 
 	if (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH) {
 		yaffs_strcpy(obj->shortName, name);
 	} else {
@@ -1932,6 +1930,9 @@
 {
 	yaffs_Object *tn = NULL;
 
+#ifdef VALGRIND_TEST
+	tn = YMALLOC(sizeof(yaffs_Object));
+#else
 	/* If there are none left make more */
 	if (!dev->freeObjects) {
 		yaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);
@@ -1942,16 +1943,27 @@
 		dev->freeObjects =
 		    (yaffs_Object *) (dev->freeObjects->siblings.next);
 		dev->nFreeObjects--;
-
+	}
+#endif
+	if(tn){
 		/* Now sweeten it up... */
 
 		memset(tn, 0, sizeof(yaffs_Object));
+		tn->beingCreated = 1;
+		
 		tn->myDev = dev;
 		tn->hdrChunk = 0;
 		tn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;
 		YINIT_LIST_HEAD(&(tn->hardLinks));
 		YINIT_LIST_HEAD(&(tn->hashLink));
 		YINIT_LIST_HEAD(&tn->siblings);
+		
+
+		/* Now make the directory sane */
+		if(dev->rootDir){
+			tn->parent = dev->rootDir;
+			ylist_add(&(tn->siblings),&dev->rootDir->variant.directoryVariant.children);
+		}
 
                 /* Add it to the lost and found directory.
                  * NB Can't put root or lostNFound in lostNFound so
@@ -1960,6 +1972,8 @@
 		if (dev->lostNFoundDir) {
 			yaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);
 		}
+		
+		tn->beingCreated = 0;
 	}
 	
 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
@@ -2009,6 +2023,16 @@
 	yaffs_Device *dev = tn->myDev;
 
 #ifdef  __KERNEL__
+	T(YAFFS_TRACE_OS,(TSTR("FreeObject %p inode %p"TENDSTR),tn,tn->myInode));
+#endif
+	
+	if(tn->parent)
+		YBUG();
+	if(!ylist_empty(&tn->siblings))
+		YBUG();
+
+
+#ifdef  __KERNEL__
 	if (tn->myInode) {
 		/* We're still hooked up to a cached inode.
 		 * Don't delete now, but mark for later deletion
@@ -2020,11 +2044,14 @@
 
         yaffs_UnhashObject(tn);
 
+#ifdef VALGRIND_TEST
+	YFREE(tn);
+#else
         /* Link into the free list. */
         tn->siblings.next = (struct ylist_head *)(dev->freeObjects);
         dev->freeObjects = tn;
         dev->nFreeObjects++;
-
+#endif
 	dev->nCheckpointBlocksRequired = 0; /* force recalculation*/
 
 }
@@ -2308,6 +2335,9 @@
 	}
 
 	in = yaffs_CreateNewObject(dev, -1, type);
+
+	if(!in)
+		return YAFFS_FAIL;
 	
 	if(type == YAFFS_OBJECT_TYPE_SYMLINK){
 		str = yaffs_CloneString(aliasString);
@@ -2368,7 +2398,7 @@
 
 		if (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {
 			/* Could not create the object header, fail the creation */
-			yaffs_DestroyObject(in);
+			yaffs_DeleteObject(in);
 			in = NULL;
 		}
 
@@ -2438,7 +2468,7 @@
 	if (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		T(YAFFS_TRACE_ALWAYS,
 		  (TSTR
-		   ("tragendy: yaffs_ChangeObjectName: newDir is not a directory"
+		   ("tragedy: yaffs_ChangeObjectName: newDir is not a directory"
 		    TENDSTR)));
 		YBUG();
 	}
@@ -2485,9 +2515,15 @@
 int yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,
 		       yaffs_Object * newDir, const YCHAR * newName)
 {
-	yaffs_Object *obj;
-	yaffs_Object *existingTarget;
+	yaffs_Object *obj=NULL;
+	yaffs_Object *existingTarget=NULL;
 	int force = 0;
+	
+	
+	if(!oldDir || oldDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
+	if(!newDir || newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY)
+		YBUG();
 
 #ifdef CONFIG_YAFFS_CASE_INSENSITIVE
 	/* Special case for case insemsitive systems (eg. WinCE).
@@ -2499,17 +2535,12 @@
 	}
 #endif
 
-	obj = yaffs_FindObjectByName(oldDir, oldName);
-	/* Check new name to long. */
-	if (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK &&
-	    yaffs_strlen(newName) > YAFFS_MAX_ALIAS_LENGTH)
-	  /* ENAMETOOLONG */
-	  return YAFFS_FAIL;
-	else if (obj->variantType != YAFFS_OBJECT_TYPE_SYMLINK &&
-		 yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
+	else if (yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)
 	  /* ENAMETOOLONG */
 	  return YAFFS_FAIL;
 
+	obj = yaffs_FindObjectByName(oldDir, oldName);
+
 	if (obj && obj->renameAllowed) {
 
 		/* Now do the handling for an existing target, if there is one */
@@ -2823,7 +2854,7 @@
 		 * Can't get space to gc
 		 */
 		T(YAFFS_TRACE_ERROR,
-		  (TSTR("yaffs tragedy: no more eraased blocks" TENDSTR)));
+		  (TSTR("yaffs tragedy: no more erased blocks" TENDSTR)));
 
 		return -1;
 	}
@@ -2854,7 +2885,7 @@
 
 	T(YAFFS_TRACE_ALWAYS,
 	  (TSTR
-	   ("yaffs tragedy: no more eraased blocks, but there should have been %d"
+	   ("yaffs tragedy: no more erased blocks, but there should have been %d"
 	    TENDSTR), dev->nErasedBlocks));
 
 	return -1;
@@ -2864,7 +2895,8 @@
 
 static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)
 {
-	if(!dev->nCheckpointBlocksRequired){
+	if(!dev->nCheckpointBlocksRequired &&
+	   dev->isYaffs2){
 		/* Not a valid value so recalculate */
 		int nBytes = 0;
 		int nBlocks;
@@ -2903,9 +2935,14 @@
 	int reservedBlocks = dev->nReservedBlocks;
 	int checkpointBlocks;
 	
-	checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;
-	if(checkpointBlocks < 0)
-		checkpointBlocks = 0;
+	if(dev->isYaffs2){
+		checkpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - 
+				    dev->blocksInCheckpoint;
+		if(checkpointBlocks < 0)
+			checkpointBlocks = 0;
+	} else {
+		checkpointBlocks =0;
+	}
 	
 	reservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);
 	
@@ -2979,17 +3016,17 @@
 
 }
 
-static int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block)
+static int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block, int wholeBlock)
 {
 	int oldChunk;
 	int newChunk;
-	int chunkInBlock;
 	int markNAND;
 	int retVal = YAFFS_OK;
 	int cleanups = 0;
 	int i;
 	int isCheckpointBlock;
 	int matchingChunk;
+	int maxCopies;
 
 	int chunksBefore = yaffs_GetErasedChunks(dev);
 	int chunksAfter;
@@ -3005,8 +3042,11 @@
 	bi->blockState = YAFFS_BLOCK_STATE_COLLECTING;
 
 	T(YAFFS_TRACE_TRACING,
-	  (TSTR("Collecting block %d, in use %d, shrink %d, " TENDSTR), block,
-	   bi->pagesInUse, bi->hasShrinkHeader));
+	  (TSTR("Collecting block %d, in use %d, shrink %d, wholeBlock %d" TENDSTR), 
+	  block,
+	  bi->pagesInUse,
+	  bi->hasShrinkHeader,
+	  wholeBlock));
 
 	/*yaffs_VerifyFreeChunks(dev); */
 
@@ -3032,13 +3072,20 @@
 		
 		yaffs_VerifyBlock(dev,bi,block);
 
-		for (chunkInBlock = 0, oldChunk = block * dev->nChunksPerBlock;
-		     chunkInBlock < dev->nChunksPerBlock
-		     && yaffs_StillSomeChunkBits(dev, block);
-		     chunkInBlock++, oldChunk++) {
-			if (yaffs_CheckChunkBit(dev, block, chunkInBlock)) {
+		maxCopies = (wholeBlock) ? dev->nChunksPerBlock : 10;
+		oldChunk = block * dev->nChunksPerBlock + dev->gcChunk;
+		
+		for ( /* init already done */;
+		     retVal == YAFFS_OK &&
+		     dev->gcChunk < dev->nChunksPerBlock &&
+		     (bi->blockState == YAFFS_BLOCK_STATE_COLLECTING)&&
+		     maxCopies > 0;
+		     dev->gcChunk++, oldChunk++) {
+			if (yaffs_CheckChunkBit(dev, block, dev->gcChunk)) {
 
 				/* This page is in use and might need to be copied off */
+				
+				maxCopies--;
 
 				markNAND = 1;
 
@@ -3053,8 +3100,8 @@
 
 				T(YAFFS_TRACE_GC_DETAIL,
 				  (TSTR
-				   ("Collecting page %d, %d %d %d " TENDSTR),
-				   chunkInBlock, tags.objectId, tags.chunkId,
+				   ("Collecting chunk in block %d, %d %d %d " TENDSTR),
+				   dev->gcChunk, tags.objectId, tags.chunkId,
 				   tags.byteCount));
 				   
 				if(object && !yaffs_SkipVerification(dev)){
@@ -3080,9 +3127,11 @@
 					    tags.objectId, tags.chunkId, tags.byteCount));
 				}
 
-				if (object && object->deleted
-				    && tags.chunkId != 0) {
-					/* Data chunk in a deleted file, throw it away
+				if (object && 
+				    object->deleted &&
+				    object->softDeleted &&
+				    tags.chunkId != 0) {
+					/* Data chunk in a soft deleted file, throw it away
 					 * It's a soft deleted data chunk,
 					 * No need to copy this, just forget about it and 
 					 * fix up the object.
@@ -3125,14 +3174,11 @@
 						 * We need to nuke the shrinkheader flags first
 						 * We no longer want the shrinkHeader flag since its work is done
 						 * and if it is left in place it will mess up scanning.
-						 * Also, clear out any shadowing stuff
 						 */
 
 						yaffs_ObjectHeader *oh;
 						oh = (yaffs_ObjectHeader *)buffer;
 						oh->isShrink = 0;
-						oh->shadowsObject = oh->inbandShadowsObject = -1;
-						tags.extraShadows = 0;
 						tags.extraIsShrinkHeader = 0;
 						
 						yaffs_VerifyObjectHeader(object,oh,&tags,1);
@@ -3161,7 +3207,8 @@
 					}
 				}
 
-				yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
+				if(retVal == YAFFS_OK)
+					yaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);
 
 			}
 		}
@@ -3201,9 +3248,15 @@
 		    TENDSTR), chunksBefore, chunksAfter));
 	}
 
+	/* If the gc completed then clear the current gcBlock so that we find another. */
+	if(bi->blockState != YAFFS_BLOCK_STATE_COLLECTING){
+		dev->gcBlock = -1;
+		dev->gcChunk = 0;
+	}
+	
 	dev->isDoingGC = 0;
 
-	return YAFFS_OK;
+	return retVal;
 }
 
 /* New garbage collector
@@ -3248,7 +3301,12 @@
 			aggressive = 0;
 		}
 
-		block = yaffs_FindBlockForGarbageCollection(dev, aggressive);
+		if(dev->gcBlock <= 0){
+			dev->gcBlock = yaffs_FindBlockForGarbageCollection(dev, aggressive);
+			dev->gcChunk = 0;
+		}
+		
+		block = dev->gcBlock;
 
 		if (block > 0) {
 			dev->garbageCollections++;
@@ -3261,7 +3319,7 @@
 			   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),
 			   dev->nErasedBlocks, aggressive));
 
-			gcOk = yaffs_GarbageCollectBlock(dev, block);
+			gcOk = yaffs_GarbageCollectBlock(dev,block,aggressive);
 		}
 
 		if (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {
@@ -3270,8 +3328,9 @@
 			   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"
 			    TENDSTR), dev->nErasedBlocks, maxTries, block));
 		}
-	} while ((dev->nErasedBlocks < dev->nReservedBlocks) && (block > 0)
-		 && (maxTries < 2));
+	} while ((dev->nErasedBlocks < dev->nReservedBlocks) && 
+		 (block > 0) &&
+		 (maxTries < 2));
 
 	return aggressive ? gcOk : YAFFS_OK;
 }
@@ -3505,8 +3564,10 @@
 			 * not be loaded during a scan
 			 */
 
-			newSerial = newTags.serialNumber;
-			existingSerial = existingTags.serialNumber;
+			if(inScan > 0) {
+				newSerial = newTags.serialNumber;
+				existingSerial = existingTags.serialNumber;
+			}
 
 			if ((inScan > 0) &&
 			    (in->myDev->isYaffs2 ||
@@ -3654,6 +3715,14 @@
 	newTags.serialNumber =
 	    (prevChunkId >= 0) ? prevTags.serialNumber + 1 : 1;
 	newTags.byteCount = nBytes;
+	
+	if(nBytes < 1 || nBytes > dev->totalBytesPerChunk){
+	  T(YAFFS_TRACE_ERROR,
+	  (TSTR("Writing %d bytes to chunk!!!!!!!!!" TENDSTR), nBytes));
+	  YBUG();
+     }
+	
+	
 
 	newChunkId =
 	    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,
@@ -3963,35 +4032,15 @@
 static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device * dev)
 {
 	int i;
-	int usage;
-	int theOne;
 
 	if (dev->nShortOpCaches > 0) {
 		for (i = 0; i < dev->nShortOpCaches; i++) {
 			if (!dev->srCache[i].object) 
 				return &dev->srCache[i];
 		}
-
-		return NULL;
-
-		theOne = -1;
-		usage = 0;	/* just to stop the compiler grizzling */
-
-		for (i = 0; i < dev->nShortOpCaches; i++) {
-			if (!dev->srCache[i].dirty &&
-			    ((dev->srCache[i].lastUse < usage && theOne >= 0) ||
-			     theOne < 0)) {
-				usage = dev->srCache[i].lastUse;
-				theOne = i;
-			}
-		}
-
-
-		return theOne >= 0 ? &dev->srCache[theOne] : NULL;
-	} else {
-		return NULL;
 	}
 
+	return NULL;
 }
 
 static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device * dev)
@@ -4278,7 +4327,7 @@
 
 	if (obj->variantType != cp->variantType) {
 		T(YAFFS_TRACE_ERROR,(TSTR("Checkpoint read object %d type %d "
-			"chunk %d does not match existing object type %d"
+			TCONT("chunk %d does not match existing object type %d")
 			TENDSTR), cp->objectId, cp->variantType, cp->hdrChunk,
 			obj->variantType));
 		return 0;
@@ -4296,7 +4345,9 @@
 		
 	if(parent) {
 		if (parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
-			T(YAFFS_TRACE_ALWAYS,(TSTR("Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory"TENDSTR),
+			T(YAFFS_TRACE_ALWAYS,(TSTR("Checkpoint read object %d parent %d type %d"
+				TCONT(" chunk %d Parent type, %d, not directory")
+				TENDSTR),
 				cp->objectId,cp->parentId,cp->variantType,cp->hdrChunk,parent->variantType));
 			return 0;
 		}
@@ -4351,7 +4402,6 @@
 			}
 		} else if (level == 0) {
 			__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;
-			/* printf("write tnode at %d\n",baseOffset); */
 			ok = (yaffs_CheckpointWrite(dev,&baseOffset,sizeof(baseOffset)) == sizeof(baseOffset));
 			if(ok)
 				ok = (yaffs_CheckpointWrite(dev,tn,tnodeSize) == tnodeSize);
@@ -4400,7 +4450,6 @@
 		/* Read level 0 tnode */
 		
 		
-		/* printf("read  tnode at %d\n",baseChunk); */
 		tn = yaffs_GetTnodeRaw(dev);
 		if(tn)
 			ok = (yaffs_CheckpointRead(dev,tn,tnodeSize) == tnodeSize);
@@ -4764,14 +4813,9 @@
 
 				cache->locked = 1;
 
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_UnlockYAFFS(TRUE);
-#endif
+
 				memcpy(buffer, &cache->data[start], nToCopy);
 
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_LockYAFFS(TRUE);
-#endif
 				cache->locked = 0;
 			} else {
 				/* Read into the local buffer then copy..*/
@@ -4780,41 +4824,19 @@
 				    yaffs_GetTempBuffer(dev, __LINE__);
 				yaffs_ReadChunkDataFromObject(in, chunk,
 							      localBuffer);
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_UnlockYAFFS(TRUE);
-#endif
+
 				memcpy(buffer, &localBuffer[start], nToCopy);
 
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_LockYAFFS(TRUE);
-#endif
+
 				yaffs_ReleaseTempBuffer(dev, localBuffer,
 							__LINE__);
 			}
 
 		} else {
-#ifdef CONFIG_YAFFS_WINCE
-			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
-
-			/* Under WinCE can't do direct transfer. Need to use a local buffer.
-			 * This is because we otherwise screw up WinCE's memory mapper
-			 */
-			yaffs_ReadChunkDataFromObject(in, chunk, localBuffer);
 
-#ifdef CONFIG_YAFFS_WINCE
-			yfsd_UnlockYAFFS(TRUE);
-#endif
-			memcpy(buffer, localBuffer, dev->nDataBytesPerChunk);
-
-#ifdef CONFIG_YAFFS_WINCE
-			yfsd_LockYAFFS(TRUE);
-			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
-#endif
-
-#else
 			/* A full chunk. Read directly into the supplied buffer. */
 			yaffs_ReadChunkDataFromObject(in, chunk, buffer);
-#endif
+
 		}
 
 		n -= nToCopy;
@@ -4839,7 +4861,8 @@
         int nToWriteBack;
         int startOfWrite = offset;
         int chunkWritten = 0;
-        int nBytesRead;
+        __u32 nBytesRead;
+        __u32 chunkStart;
 
 	yaffs_Device *dev;
 
@@ -4849,6 +4872,14 @@
 		//chunk = offset / dev->nDataBytesPerChunk + 1;
 		//start = offset % dev->nDataBytesPerChunk;
 		yaffs_AddrToChunk(dev,offset,&chunk,&start);
+		
+		if(chunk * dev->nDataBytesPerChunk + start != offset ||
+		   start >= dev->nDataBytesPerChunk){
+		   T(YAFFS_TRACE_ERROR,(
+			   TSTR("AddrToChunk of offset %d gives chunk %d start %d"
+			   TENDSTR),
+		   	   (int)offset, chunk,start));
+		}
 		chunk++;
 
 		/* OK now check for the curveball where the start and end are in
@@ -4863,9 +4894,12 @@
 			 * we need to write back as much as was there before.
 			 */
 
-			nBytesRead =
-			    in->variant.fileVariant.fileSize -
-			    ((chunk - 1) * dev->nDataBytesPerChunk);
+			chunkStart = ((chunk - 1) * dev->nDataBytesPerChunk);
+
+			if(chunkStart > in->variant.fileVariant.fileSize)
+				nBytesRead = 0; /* Past end of file */
+			else
+				nBytesRead = in->variant.fileVariant.fileSize - chunkStart;
 
 			if (nBytesRead > dev->nDataBytesPerChunk) {
 				nBytesRead = dev->nDataBytesPerChunk;
@@ -4874,6 +4908,9 @@
 			nToWriteBack =
 			    (nBytesRead >
 			     (start + n)) ? nBytesRead : (start + n);
+			
+			if(nToWriteBack < 0 || nToWriteBack > dev->nDataBytesPerChunk)
+				YBUG();
 
 		} else {
 			nToCopy = dev->nDataBytesPerChunk - start;
@@ -4913,16 +4950,12 @@
 				if (cache) {
 					yaffs_UseChunkCache(dev, cache, 1);
 					cache->locked = 1;
-#ifdef CONFIG_YAFFS_WINCE
-					yfsd_UnlockYAFFS(TRUE);
-#endif
+
 
 					memcpy(&cache->data[start], buffer,
 					       nToCopy);
 
-#ifdef CONFIG_YAFFS_WINCE
-					yfsd_LockYAFFS(TRUE);
-#endif
+
 					cache->locked = 0;
 					cache->nBytes = nToWriteBack;
 
@@ -4950,15 +4983,10 @@
 				yaffs_ReadChunkDataFromObject(in, chunk,
 							      localBuffer);
 
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_UnlockYAFFS(TRUE);
-#endif
+
 
 				memcpy(&localBuffer[start], buffer, nToCopy);
 
-#ifdef CONFIG_YAFFS_WINCE
-				yfsd_LockYAFFS(TRUE);
-#endif
 				chunkWritten =
 				    yaffs_WriteChunkDataToObject(in, chunk,
 								 localBuffer,
@@ -4973,30 +5001,13 @@
 		} else {
 			/* A full chunk. Write directly from the supplied buffer. */
 			
-#ifdef CONFIG_YAFFS_WINCE
-			/* Under WinCE can't do direct transfer. Need to use a local buffer.
-			 * This is because we otherwise screw up WinCE's memory mapper
-			 */
-			__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);
-#ifdef CONFIG_YAFFS_WINCE
-			yfsd_UnlockYAFFS(TRUE);
-#endif
-			memcpy(localBuffer, buffer, dev->nDataBytesPerChunk);
-#ifdef CONFIG_YAFFS_WINCE
-			yfsd_LockYAFFS(TRUE);
-#endif
-			chunkWritten =
-			    yaffs_WriteChunkDataToObject(in, chunk, localBuffer,
-							 dev->nDataBytesPerChunk,
-							 0);
-			yaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);
-#else
+
 
 			chunkWritten =
 			    yaffs_WriteChunkDataToObject(in, chunk, buffer,
 							 dev->nDataBytesPerChunk,
 							 0);
-#endif
+
 			/* Since we've overwritten the cached data, we better invalidate it. */
 			yaffs_InvalidateChunkCache(in, chunk);
 		}
@@ -5125,7 +5136,8 @@
 	 * show we've shrunk the file, if need be
 	 * Do this only if the file is not in the deleted directories.
 	 */
-	if (in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
+	if (in->parent &&
+	    in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&
 	    in->parent->objectId != YAFFS_OBJECTID_DELETED) {
 		yaffs_UpdateObjectHeader(in, NULL, 0,
 					 (newSize < oldFileSize) ? 1 : 0, 0);
@@ -5201,62 +5213,65 @@
  * and the inode associated with the file.
  * It does not delete the links associated with the file.
  */
-static int yaffs_UnlinkFile(yaffs_Object * in)
+static int yaffs_UnlinkFileIfNeeded(yaffs_Object * in)
 {
 
 	int retVal;
 	int immediateDeletion = 0;
 
-	if (1) {
 #ifdef __KERNEL__
-		if (!in->myInode) {
-			immediateDeletion = 1;
-
-		}
+	if (!in->myInode) {
+		immediateDeletion = 1;
+	}
 #else
-		if (in->inUse <= 0) {
-			immediateDeletion = 1;
-
-		}
+	if (in->inUse <= 0) {
+		immediateDeletion = 1;
+	}
 #endif
-		if (immediateDeletion) {
-			retVal =
-			    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
-						   _Y("deleted"), 0, 0);
-			T(YAFFS_TRACE_TRACING,
-			  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
-			   in->objectId));
-			in->deleted = 1;
-			in->myDev->nDeletedFiles++;
-			if (0 && in->myDev->isYaffs2) {
-				yaffs_ResizeFile(in, 0);
-			}
-			yaffs_SoftDeleteFile(in);
-		} else {
-			retVal =
-			    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
-						   _Y("unlinked"), 0, 0);
-		}
 
+	if (immediateDeletion) {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->deletedDir,
+					   _Y("deleted"), 0, 0);
+		T(YAFFS_TRACE_TRACING,
+		  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),
+		   in->objectId));
+		in->deleted = 1;
+		in->myDev->nDeletedFiles++;
+		if (1 || in->myDev->isYaffs2) {
+			yaffs_ResizeFile(in, 0);
+		}
+		yaffs_SoftDeleteFile(in);
+	} else {
+		retVal =
+		    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
 	}
+
+
 	return retVal;
 }
 
 int yaffs_DeleteFile(yaffs_Object * in)
 {
 	int retVal = YAFFS_OK;
+	int deleted = in->deleted;
+	
+	yaffs_ResizeFile(in,0);
 
 	if (in->nDataChunks > 0) {
-		/* Use soft deletion if there is data in the file */
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
 		if (!in->unlinked) {
-			retVal = yaffs_UnlinkFile(in);
+			retVal = yaffs_UnlinkFileIfNeeded(in);
 		}
 		if (retVal == YAFFS_OK && in->unlinked && !in->deleted) {
-			in->deleted = 1;
+			in->deleted = deleted = 1;
 			in->myDev->nDeletedFiles++;
 			yaffs_SoftDeleteFile(in);
 		}
-		return in->deleted ? YAFFS_OK : YAFFS_FAIL;
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
 	} else {
 		/* The file has no data chunks so we toss it immediately */
 		yaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);
@@ -5290,36 +5305,52 @@
         /* remove this hardlink from the list assocaited with the equivalent
          * object
          */
-        ylist_del(&in->hardLinks);
+        ylist_del_init(&in->hardLinks);
         return yaffs_DoGenericObjectDeletion(in);
 }
 
-static void yaffs_DestroyObject(yaffs_Object * obj)
+int yaffs_DeleteObject(yaffs_Object * obj)
 {
+int retVal = -1;
 	switch (obj->variantType) {
 	case YAFFS_OBJECT_TYPE_FILE:
-		yaffs_DeleteFile(obj);
+		retVal = yaffs_DeleteFile(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_DIRECTORY:
-		yaffs_DeleteDirectory(obj);
+		return yaffs_DeleteDirectory(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_SYMLINK:
-		yaffs_DeleteSymLink(obj);
+		retVal = yaffs_DeleteSymLink(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_HARDLINK:
-		yaffs_DeleteHardLink(obj);
+		retVal = yaffs_DeleteHardLink(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_SPECIAL:
-		yaffs_DoGenericObjectDeletion(obj);
+		retVal = yaffs_DoGenericObjectDeletion(obj);
 		break;
 	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	        retVal = 0;
 		break;		/* should not happen. */
 	}
+	
+	return retVal;
 }
 
 static int yaffs_UnlinkWorker(yaffs_Object * obj)
 {
 
+	int immediateDeletion = 0;
+
+#ifdef __KERNEL__
+	if (!obj->myInode) {
+		immediateDeletion = 1;
+	}
+#else
+	if (obj->inUse <= 0) {
+		immediateDeletion = 1;
+	}
+#endif
+
         if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {
                 return yaffs_DeleteHardLink(obj);
         } else if (!ylist_empty(&obj->hardLinks)) {
@@ -5355,10 +5386,10 @@
 		}
 		return retVal;
 
-	} else {
+	} else if(immediateDeletion){
 		switch (obj->variantType) {
 		case YAFFS_OBJECT_TYPE_FILE:
-			return yaffs_UnlinkFile(obj);
+			return yaffs_DeleteFile(obj);
 			break;
 		case YAFFS_OBJECT_TYPE_DIRECTORY:
 			return yaffs_DeleteDirectory(obj);
@@ -5374,6 +5405,9 @@
 		default:
 			return YAFFS_FAIL;
 		}
+	} else {
+		return yaffs_ChangeObjectName(obj, obj->myDev->unlinkedDir,
+					   _Y("unlinked"), 0, 0);
 	}
 }
 
@@ -5505,7 +5539,7 @@
 		&dev->unlinkedDir->variant.directoryVariant.children) {
 		if (i) {
 			l = ylist_entry(i, yaffs_Object, siblings);
-			yaffs_DestroyObject(l);
+			yaffs_DeleteObject(l);
 		}
 	}
 	
@@ -5513,7 +5547,7 @@
 		&dev->deletedDir->variant.directoryVariant.children) {
 		if (i) {
 			l = ylist_entry(i, yaffs_Object, siblings);
-			yaffs_DestroyObject(l);
+			yaffs_DeleteObject(l);
 		}
 	}
 
@@ -5709,7 +5743,7 @@
 					 * deleted, and worse still it has changed type. Delete the old object.
 					 */
 
-					yaffs_DestroyObject(in);
+					yaffs_DeleteObject(in);
 
 					in = 0;
 				}
@@ -5778,6 +5812,7 @@
 					in->yst_rdev = oh->yst_rdev;
 #endif
 					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
 
 				} else if (in && !in->valid) {
 					/* we need to load this info */
@@ -5802,6 +5837,7 @@
 					in->yst_rdev = oh->yst_rdev;
 #endif
 					in->hdrChunk = chunk;
+					in->serial = tags.serialNumber;
 
 					yaffs_SetObjectName(in, oh->name);
 					in->dirty = 0;
@@ -5887,10 +5923,12 @@
 						break;
 					}
 
-					if (parent == dev->deletedDir) {
+/*
+ 					if (parent == dev->deletedDir) {
 						yaffs_DestroyObject(in);
 						bi->hasShrinkHeader = 1;
 					}
+*/
 				}
 			}
 		}
@@ -5933,7 +5971,7 @@
 			 */
 			obj = yaffs_FindObjectByNumber(dev,fixer->shadowedId);
 			if(obj)
-				yaffs_DestroyObject(obj);
+				yaffs_DeleteObject(obj);
 	
 			obj = yaffs_FindObjectByNumber(dev,fixer->objectId);
 			if(obj){
@@ -5960,7 +5998,7 @@
 {
 	__u8 *chunkData;
 	yaffs_ObjectHeader *oh;
-	yaffs_Device *dev = in->myDev;
+	yaffs_Device *dev;
 	yaffs_ExtendedTags tags;
 	int result;
 	int alloc_failed = 0;
@@ -5968,6 +6006,8 @@
 	if(!in)
 		return;
 		
+	dev = in->myDev;
+		
 #if 0
 	T(YAFFS_TRACE_SCAN,(TSTR("details for object %d %s loaded" TENDSTR),
 		in->objectId,
@@ -6266,10 +6306,11 @@
 			} else if (tags.eccResult == YAFFS_ECC_RESULT_UNFIXED){
 				T(YAFFS_TRACE_SCAN,
 				  (TSTR(" Unfixed ECC in chunk(%d:%d), chunk ignored"TENDSTR),
-  				  blk, c));
+				  blk, c));
 
-  				  dev->nFreeChunks++;
-  			} else if (tags.chunkId > 0) {
+				  dev->nFreeChunks++;
+
+			}else if (tags.chunkId > 0) {
 				/* chunkId > 0 so it is a data chunk... */
 				unsigned int endpos;
 				__u32 chunkBase =
@@ -6408,7 +6449,9 @@
 						    (oh) ? oh->
 						    parentObjectId : tags.
 						    extraParentObjectId;
-						unsigned isShrink =
+						
+						
+						isShrink =
 						    (oh) ? oh->isShrink : tags.
 						    extraIsShrinkHeader;
 
@@ -6443,10 +6486,11 @@
 
 				if (!in->valid && in->variantType !=
 				    (oh ? oh->type : tags.extraObjectType))
-					T(YAFFS_TRACE_ERROR, (TSTR
-					   ("yaffs tragedy: Bad object type, "
-					    "%d != %d, for object %d at chunk "
-					    "%d during scan" TENDSTR), oh ?
+					T(YAFFS_TRACE_ERROR, (
+						TSTR("yaffs tragedy: Bad object type, "
+					    TCONT("%d != %d, for object %d at chunk ")
+					    TCONT("%d during scan")
+						TENDSTR), oh ?
 					    oh->type : tags.extraObjectType,
 					    in->variantType, tags.objectId,
 					    chunk));
@@ -6687,15 +6731,106 @@
 
 /*------------------------------  Directory Functions ----------------------------- */
 
+static void yaffs_VerifyObjectInDirectory(yaffs_Object *obj)
+{
+        struct ylist_head *lh;
+        yaffs_Object *listObj;
+        
+        int count = 0;
+
+	if(!obj){
+		T(YAFFS_TRACE_ALWAYS, (TSTR("No object to verify" TENDSTR)));
+		YBUG();
+		return;
+	}
+
+        if(yaffs_SkipVerification(obj->myDev))
+                return;
+
+	if(!obj->parent){
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object does not have parent" TENDSTR)));
+		YBUG();
+		return;
+	}
+		
+	if(obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Parent is not directory" TENDSTR)));
+		YBUG();
+	}
+	
+        /* Iterate through the objects in each hash entry */
+         
+        ylist_for_each(lh, &obj->parent->variant.directoryVariant.children) {
+		if (lh) {
+                        listObj = ylist_entry(lh, yaffs_Object, siblings);
+			yaffs_VerifyObject(listObj);
+			if(obj == listObj)
+				count ++;
+                }
+	 }
+	 
+	 if(count != 1){
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory %d times" TENDSTR),count));
+		YBUG();
+	}
+
+}
+
+static void yaffs_VerifyDirectory(yaffs_Object *directory)
+{
+
+        struct ylist_head *lh;
+        yaffs_Object *listObj;
+        
+	if(!directory){
+		YBUG();
+		return;
+	}
+
+        if(yaffs_SkipFullVerification(directory->myDev))
+                return;
+
+		
+	if(directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){
+		T(YAFFS_TRACE_ALWAYS, (TSTR("Directory has wrong type: %d" TENDSTR),directory->variantType));
+		YBUG();
+	}
+	
+        /* Iterate through the objects in each hash entry */
+         
+        ylist_for_each(lh, &directory->variant.directoryVariant.children) {
+		if (lh) {
+                        listObj = ylist_entry(lh, yaffs_Object, siblings);
+			if(listObj->parent != directory){
+				T(YAFFS_TRACE_ALWAYS, (TSTR("Object in directory list has wrong parent %p" TENDSTR),listObj->parent));
+				YBUG();
+			}
+			yaffs_VerifyObjectInDirectory(listObj);
+                }
+	 }
+	 
+}
+
+
 static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj)
 {
 	yaffs_Device *dev = obj->myDev;
+	yaffs_Object *parent;
+	
+        yaffs_VerifyObjectInDirectory(obj);
+	parent = obj->parent;
 	
+	yaffs_VerifyDirectory(parent);
+
         if(dev && dev->removeObjectCallback)
                 dev->removeObjectCallback(obj);
+
            
         ylist_del_init(&obj->siblings);
         obj->parent = NULL;
+
+	yaffs_VerifyDirectory(parent);
+
 }
 
 
@@ -6709,6 +6844,7 @@
 		   ("tragedy: Trying to add an object to a null pointer directory"
 		    TENDSTR)));
 		YBUG();
+		return;
 	}
 	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		T(YAFFS_TRACE_ALWAYS,
@@ -6720,12 +6856,15 @@
 
         if (obj->siblings.prev == NULL) {
                 /* Not initialised */
-                YINIT_LIST_HEAD(&obj->siblings);
+                YBUG();
 
-        } else if (!ylist_empty(&obj->siblings)) {
-                /* If it is holed up somewhere else, un hook it */
-                yaffs_RemoveObjectFromDirectory(obj);
-        }
+        } 
+
+	yaffs_VerifyDirectory(directory);
+
+	yaffs_RemoveObjectFromDirectory(obj);
+        
+        
         /* Now add it */
         ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);
         obj->parent = directory;
@@ -6736,6 +6875,11 @@
 		obj->myDev->nUnlinkedFiles++;
 		obj->renameAllowed = 0;
 	}
+
+	yaffs_VerifyDirectory(directory);
+        yaffs_VerifyObjectInDirectory(obj);
+
+
 }
 
 yaffs_Object *yaffs_FindObjectByName(yaffs_Object * directory,
@@ -6758,6 +6902,7 @@
 		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
 		    TENDSTR)));
 		YBUG();
+		return NULL;
 	}
 	if (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		T(YAFFS_TRACE_ALWAYS,
@@ -6772,6 +6917,9 @@
                 if (i) {
                         l = ylist_entry(i, yaffs_Object, siblings);
                         
+                        if(l->parent != directory)
+                        	YBUG();
+                        
                         yaffs_CheckObjectDetailsLoaded(l);
 
 			/* Special case for lost-n-found */
@@ -6810,12 +6958,14 @@
 		   ("tragedy: yaffs_FindObjectByName: null pointer directory"
 		    TENDSTR)));
 		YBUG();
+		return YAFFS_FAIL;
 	}
 	if (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {
 		T(YAFFS_TRACE_ALWAYS,
 		  (TSTR
 		   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));
                 YBUG();
+                return YAFFS_FAIL;
         }
 
         ylist_for_each(i, &theDir->variant.directoryVariant.children) {
@@ -6857,9 +7007,18 @@
 		yaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);
 	} else if (obj->hdrChunk <= 0) {
 		YCHAR locName[20];
+		YCHAR numString[20];
+		YCHAR *x = &numString[19];
+		unsigned v = obj->objectId;
+		numString[19] = 0;
+		while(v>0){
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
 		/* make up a name */
-		yaffs_sprintf(locName, _Y("%s%d"), YAFFS_LOSTNFOUND_PREFIX,
-			      obj->objectId);
+		yaffs_strcpy(locName, YAFFS_LOSTNFOUND_PREFIX);
+		yaffs_strcat(locName,x);
 		yaffs_strncpy(name, locName, buffSize - 1);
 
 	}
@@ -7127,6 +7286,8 @@
 	dev->blockOffset = 0;
 	dev->chunkOffset = 0;
 	dev->nFreeChunks = 0;
+	
+	dev->gcBlock = -1;
 
 	if (dev->startBlock == 0) {
 		dev->internalStartBlock = dev->startBlock + 1;
@@ -7138,7 +7299,7 @@
 	/* Check geometry parameters. */
 
 	if ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) || 
-	    (!dev->isYaffs2 && dev->totalBytesPerChunk != 512) || 
+	    (!dev->isYaffs2 && dev->totalBytesPerChunk < 512) || 
 	    (dev->inbandTags && !dev->isYaffs2 ) ||
 	     dev->nChunksPerBlock < 2 || 
 	     dev->nReservedBlocks < 2 || 
@@ -7192,24 +7353,19 @@
 
 	dev->isMounted = 1;
 
-
-
 	/* OK now calculate a few things for the device */
 	
 	/*
 	 *  Calculate all the chunk size manipulation numbers: 	 
 	 */
- 	 {
-		__u32 x = dev->nDataBytesPerChunk;
-		 /* We always use dev->chunkShift and dev->chunkDiv */
-		 dev->chunkShift = Shifts(x);
-		 x >>= dev->chunkShift;
-		 dev->chunkDiv = x;
-		 /* We only use chunk mask if chunkDiv is 1 */
-		 dev->chunkMask = (1<<dev->chunkShift) - 1;
-	}
+	x = dev->nDataBytesPerChunk;
+	/* We always use dev->chunkShift and dev->chunkDiv */
+	dev->chunkShift = Shifts(x);
+	x >>= dev->chunkShift;
+	dev->chunkDiv = x;
+	/* We only use chunk mask if chunkDiv is 1 */
+	dev->chunkMask = (1<<dev->chunkShift) - 1;
 	 	
-
 	/*
 	 * Calculate chunkGroupBits.
 	 * We need to find the next power of 2 > than internalEndBlock
@@ -7297,7 +7453,9 @@
 			dev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;
 		}
 
-		buf = dev->srCache =  YMALLOC(srCacheBytes);
+		dev->srCache =  YMALLOC(srCacheBytes);
+		
+		buf = (__u8 *) dev->srCache;
 		    
 		if(dev->srCache)
 			memset(dev->srCache,0,srCacheBytes);
@@ -7437,6 +7595,9 @@
 
 
 		dev->isMounted = 0;
+		
+		if(dev->deinitialiseNAND)
+			dev->deinitialiseNAND(dev);
 	}
 
 }
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_guts.h linux-2.6.27/fs/yaffs2/yaffs_guts.h
--- linux-2.6.27new/fs/yaffs2/yaffs_guts.h	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_guts.h	2009-07-23 17:08:11.000000000 +0800
@@ -135,12 +135,12 @@
 
 #ifndef CONFIG_YAFFS_NO_YAFFS1
 typedef struct {
-	unsigned chunkId:20;
-	unsigned serialNumber:2;
-	unsigned byteCount:10;
-	unsigned objectId:18;
-	unsigned ecc:12;
-	unsigned unusedStuff:2;
+        unsigned chunkId:20;
+        unsigned serialNumber:2;
+        unsigned byteCountLSB:10;
+        unsigned objectId:18;
+        unsigned ecc:12;
+        unsigned byteCountMSB:2;
 
 } yaffs_Tags;
 
@@ -423,7 +423,8 @@
 	__u8 deferedFree:1;	/* For Linux kernel. Object is removed from NAND, but is
 				 * still in the inode cache. Free of object is defered.
 				 * until the inode is released.
-				 */
+                                 */
+        __u8 beingCreated:1;	/* This object is still being created so skip some checks. */
 
 	__u8 serial;		/* serial number of chunk in NAND. Cached here */
 	__u16 sum;		/* sum of the name to speed searching */
@@ -575,9 +576,10 @@
 	int (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,
 				  int chunkInNAND, __u8 * data,
 				  yaffs_Spare * spare);
-	int (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev,
-				 int blockInNAND);
-	int (*initialiseNAND) (struct yaffs_DeviceStruct * dev);
+        int (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev,
+                                 int blockInNAND);
+        int (*initialiseNAND) (struct yaffs_DeviceStruct * dev);
+        int (*deinitialiseNAND) (struct yaffs_DeviceStruct * dev);
 
 #ifdef CONFIG_YAFFS_YAFFS2
 	int (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev,
@@ -691,6 +693,8 @@
 	yaffs_TnodeList *allocatedTnodeList;
 
 	int isDoingGC;
+	int gcBlock;
+	int gcChunk;
 
 	int nObjectsCreated;
 	yaffs_Object *freeObjects;
@@ -820,7 +824,7 @@
 		       yaffs_Object * newDir, const YCHAR * newName);
 
 int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);
-int yaffs_DeleteFile(yaffs_Object * obj);
+int yaffs_DeleteObject(yaffs_Object * obj);
 
 int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);
 int yaffs_GetObjectFileLength(yaffs_Object * obj);
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_mtdif1.c linux-2.6.27/fs/yaffs2/yaffs_mtdif1.c
--- linux-2.6.27new/fs/yaffs2/yaffs_mtdif1.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_mtdif1.c	2009-07-23 17:08:11.000000000 +0800
@@ -36,7 +36,7 @@
 /* Don't compile this module if we don't have MTD's mtd_oob_ops interface */
 #if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))
 
-const char *yaffs_mtdif1_c_version = "$Id$";
+const char *yaffs_mtdif1_c_version = "$Id: yaffs_mtdif1.c,v 1.8 2008/07/23 03:35:12 charles Exp $";
 
 #ifndef CONFIG_YAFFS_9BYTE_TAGS
 # define YTAG1_SIZE 8
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_mtdif2.c linux-2.6.27/fs/yaffs2/yaffs_mtdif2.c
--- linux-2.6.27new/fs/yaffs2/yaffs_mtdif2.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_mtdif2.c	2009-07-23 17:08:11.000000000 +0800
@@ -14,7 +14,7 @@
 /* mtd interface for YAFFS2 */
 
 const char *yaffs_mtdif2_c_version =
-    "$Id$";
+    "$Id: yaffs_mtdif2.c,v 1.22 2008/11/02 22:47:13 charles Exp $";
 
 #include "yportenv.h"
 
@@ -52,7 +52,6 @@
 	   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"
 	    TENDSTR), chunkInNAND, data, tags));
 	    
-	dev->nPageWrites++;
 
 	addr  = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
 	
@@ -108,7 +107,7 @@
 	int retval = 0;
 	int localData = 0;
 
-	loff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;
+	loff_t addr = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;
 
 	yaffs_PackedTags2 pt;
 
@@ -117,8 +116,6 @@
 	   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"
 	    TENDSTR), chunkInNAND, data, tags));
 	    
-	dev->nPageReads++;
-
 	if(dev->inbandTags){
 		
 		if(!data) {
@@ -179,14 +176,8 @@
 	if(localData)
 		yaffs_ReleaseTempBuffer(dev,data,__LINE__);
 	
-	if(tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
+	if(tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR)
 		tags->eccResult = YAFFS_ECC_RESULT_UNFIXED;		
-		dev->eccUnfixed++;
-	}
-	if(tags && retval == -EUCLEAN && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR) {
-		tags->eccResult = YAFFS_ECC_RESULT_FIXED;
-		dev->eccFixed++;
-	}
 	if (retval == 0)
 		return YAFFS_OK;
 	else
@@ -203,7 +194,7 @@
 	retval =
 	    mtd->block_markbad(mtd,
 			       blockNo * dev->nChunksPerBlock *
-			       dev->nDataBytesPerChunk);
+			       dev->totalBytesPerChunk);
 
 	if (retval == 0)
 		return YAFFS_OK;
@@ -223,7 +214,7 @@
 	retval =
 	    mtd->block_isbad(mtd,
 			     blockNo * dev->nChunksPerBlock *
-			     dev->nDataBytesPerChunk);
+			     dev->totalBytesPerChunk);
 
 	if (retval) {
 		T(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_mtdif.c linux-2.6.27/fs/yaffs2/yaffs_mtdif.c
--- linux-2.6.27new/fs/yaffs2/yaffs_mtdif.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_mtdif.c	2009-07-23 17:08:11.000000000 +0800
@@ -12,7 +12,7 @@
  */
 
 const char *yaffs_mtdif_c_version =
-    "$Id$";
+    "$Id: yaffs_mtdif.c,v 1.21 2007/12/13 15:35:18 wookey Exp $";
 
 #include "yportenv.h"
 
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_nand.c linux-2.6.27/fs/yaffs2/yaffs_nand.c
--- linux-2.6.27new/fs/yaffs2/yaffs_nand.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_nand.c	2009-07-23 17:08:11.000000000 +0800
@@ -12,7 +12,7 @@
  */
 
 const char *yaffs_nand_c_version =
-    "$Id$";
+    "$Id: yaffs_nand.c,v 1.9 2008/05/05 07:58:58 charles Exp $";
 
 #include "yaffs_nand.h"
 #include "yaffs_tagscompat.h"
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_packedtags2.c linux-2.6.27/fs/yaffs2/yaffs_packedtags2.c
--- linux-2.6.27new/fs/yaffs2/yaffs_packedtags2.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_packedtags2.c	2009-07-23 17:08:11.000000000 +0800
@@ -37,9 +37,6 @@
 #define EXTRA_OBJECT_TYPE_SHIFT (28)
 #define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)
 
-#ifndef CONFIG_YAFFS_DOES_ECC
-#define YAFFS_IGNORE_TAGS_ECC 1
-#endif
 
 static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart * ptt)
 {
@@ -166,15 +163,11 @@
 void yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt)
 {
 
-	yaffs_UnpackTags2TagsPart(t,&pt->t);
-
+	yaffs_ECCResult eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+	
 	if (pt->t.sequenceNumber != 0xFFFFFFFF) {
 		/* Page is in use */
-#ifdef YAFFS_IGNORE_TAGS_ECC
-		{
-			t->eccResult = YAFFS_ECC_RESULT_NO_ERROR;
-		}
-#else
+#ifndef YAFFS_IGNORE_TAGS_ECC
 		{
 			yaffs_ECCOther ecc;
 			int result;
@@ -189,21 +182,25 @@
 						  &pt->ecc, &ecc);
 			switch(result){
 				case 0:
-					t->eccResult = YAFFS_ECC_RESULT_NO_ERROR;
+					eccResult = YAFFS_ECC_RESULT_NO_ERROR;
 					break;
 				case 1:
-					t->eccResult = YAFFS_ECC_RESULT_FIXED;
+					eccResult = YAFFS_ECC_RESULT_FIXED;
 					break;
 				case -1:
-					t->eccResult = YAFFS_ECC_RESULT_UNFIXED;
+					eccResult = YAFFS_ECC_RESULT_UNFIXED;
 					break;
 				default:
-					t->eccResult = YAFFS_ECC_RESULT_UNKNOWN;
+					eccResult = YAFFS_ECC_RESULT_UNKNOWN;
 			}
 		}
 #endif
 	}
 
+	yaffs_UnpackTags2TagsPart(t,&pt->t);
+	
+	t->eccResult = eccResult;
+
 	yaffs_DumpPackedTags2(pt);
 	yaffs_DumpTags2(t);
 
diff -urN linux-2.6.27new/fs/yaffs2/yaffs_tagscompat.c linux-2.6.27/fs/yaffs2/yaffs_tagscompat.c
--- linux-2.6.27new/fs/yaffs2/yaffs_tagscompat.c	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yaffs_tagscompat.c	2009-07-23 17:08:11.000000000 +0800
@@ -418,7 +418,16 @@
 	} else {
 		tags.objectId = eTags->objectId;
 		tags.chunkId = eTags->chunkId;
-		tags.byteCount = eTags->byteCount;
+
+		tags.byteCountLSB = eTags->byteCount & 0x3ff;
+		
+		if(dev->nDataBytesPerChunk >= 1024){
+			tags.byteCountMSB = (eTags->byteCount >> 10) & 3;
+		} else {
+			tags.byteCountMSB = 3;
+		}
+		
+
 		tags.serialNumber = eTags->serialNumber;
 
 		if (!dev->useNANDECC && data) {
@@ -470,7 +479,11 @@
 
 				eTags->objectId = tags.objectId;
 				eTags->chunkId = tags.chunkId;
-				eTags->byteCount = tags.byteCount;
+				eTags->byteCount = tags.byteCountLSB;
+
+				if(dev->nDataBytesPerChunk >= 1024)
+					eTags->byteCount |= (((unsigned) tags.byteCountMSB) << 10);
+
 				eTags->serialNumber = tags.serialNumber;
 			}
 		}
diff -urN linux-2.6.27new/fs/yaffs2/yportenv.h linux-2.6.27/fs/yaffs2/yportenv.h
--- linux-2.6.27new/fs/yaffs2/yportenv.h	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/fs/yaffs2/yportenv.h	2009-07-23 17:08:11.000000000 +0800
@@ -51,6 +51,7 @@
 #define YCHAR char
 #define YUCHAR unsigned char
 #define _Y(x)     x
+#define yaffs_strcat(a,b)    strcat(a,b)
 #define yaffs_strcpy(a,b)    strcpy(a,b)
 #define yaffs_strncpy(a,b,c) strncpy(a,b,c)
 #define yaffs_strncmp(a,b,c) strncmp(a,b,c)
@@ -89,6 +90,7 @@
 
 #define TENDSTR "\n"
 #define TSTR(x) KERN_WARNING x
+#define TCONT(x) x
 #define TOUT(p) printk p
 
 #define yaffs_trace(mask, fmt, args...) \
@@ -124,6 +126,7 @@
 #define YCHAR char
 #define YUCHAR unsigned char
 #define _Y(x)     x
+#define yaffs_strcat(a,b)    strcat(a,b)
 #define yaffs_strcpy(a,b)    strcpy(a,b)
 #define yaffs_strncpy(a,b,c) strncpy(a,b,c)
 #define yaffs_strlen(s)	     strlen(s)
diff -urN linux-2.6.27new/Makefile linux-2.6.27/Makefile
--- linux-2.6.27new/Makefile	2009-07-01 17:41:58.000000000 +0800
+++ linux-2.6.27/Makefile	2009-07-23 17:08:11.000000000 +0800
@@ -190,8 +190,8 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
+ARCH		?= arm
+CROSS_COMPILE	?=arm-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
